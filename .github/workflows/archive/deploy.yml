name: Manual Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
        - development
        - staging
        - production
        default: 'development'
      
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        default: 'latest'
      
      force_deploy:
        description: 'Force deployment (skip health checks)'
        required: false
        type: boolean
        default: false

      skip_tests:
        description: 'Skip pre-deployment tests'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: registry.jclee.me
  IMAGE_NAME: jclee94/blacklist

jobs:
  pre-deployment-checks:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_tests }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Validate image exists
      run: |
        # Check if the specified image tag exists in registry
        if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.image_tag }} > /dev/null 2>&1; then
          echo "‚úÖ Image ${{ inputs.image_tag }} exists in registry"
        else
          echo "‚ùå Image ${{ inputs.image_tag }} not found in registry"
          exit 1
        fi

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov

    - name: Run critical tests
      run: |
        python -m pytest tests/ -v -k "not slow" --maxfail=5
      env:
        FLASK_ENV: testing
        FORCE_DISABLE_COLLECTION: true

    - name: Container health check
      run: |
        # Pull and test the container locally
        docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.image_tag }}
        
        # Run container and test health endpoint
        docker run -d --name test-container \
          -p 8080:2541 \
          -e FLASK_ENV=production \
          -e FORCE_DISABLE_COLLECTION=true \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.image_tag }}
        
        # Wait for container to be ready
        sleep 30
        
        # Health check
        if curl -f http://localhost:8080/health > /dev/null 2>&1; then
          echo "‚úÖ Container health check passed"
        else
          echo "‚ùå Container health check failed"
          docker logs test-container
          exit 1
        fi
        
        # Cleanup
        docker stop test-container
        docker rm test-container

  deploy-to-environment:
    name: Deploy to ${{ inputs.environment }}
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: ${{ always() && (needs.pre-deployment-checks.result == 'success' || needs.pre-deployment-checks.result == 'skipped' || inputs.force_deploy) }}
    environment: ${{ inputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set environment variables
      run: |
        case "${{ inputs.environment }}" in
          development)
            echo "NAMESPACE=blacklist-dev" >> $GITHUB_ENV
            echo "INGRESS_HOST=blacklist-dev.jclee.me" >> $GITHUB_ENV
            echo "REPLICAS=1" >> $GITHUB_ENV
            echo "RESOURCES_LIMITS_CPU=200m" >> $GITHUB_ENV
            echo "RESOURCES_LIMITS_MEMORY=256Mi" >> $GITHUB_ENV
            ;;
          staging)
            echo "NAMESPACE=blacklist-staging" >> $GITHUB_ENV
            echo "INGRESS_HOST=blacklist-staging.jclee.me" >> $GITHUB_ENV
            echo "REPLICAS=2" >> $GITHUB_ENV
            echo "RESOURCES_LIMITS_CPU=300m" >> $GITHUB_ENV
            echo "RESOURCES_LIMITS_MEMORY=384Mi" >> $GITHUB_ENV
            ;;
          production)
            echo "NAMESPACE=blacklist" >> $GITHUB_ENV
            echo "INGRESS_HOST=blacklist.jclee.me" >> $GITHUB_ENV
            echo "REPLICAS=3" >> $GITHUB_ENV
            echo "RESOURCES_LIMITS_CPU=500m" >> $GITHUB_ENV
            echo "RESOURCES_LIMITS_MEMORY=512Mi" >> $GITHUB_ENV
            ;;
        esac

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > /tmp/kubeconfig
        export KUBECONFIG=/tmp/kubeconfig
        kubectl cluster-info

    - name: Create namespace
      run: |
        export KUBECONFIG=/tmp/kubeconfig
        kubectl create namespace ${{ env.NAMESPACE }} || true
        kubectl label namespace ${{ env.NAMESPACE }} environment=${{ inputs.environment }} || true

    - name: Create registry secret
      run: |
        export KUBECONFIG=/tmp/kubeconfig
        kubectl create secret docker-registry registry-secret \
          --docker-server=${{ env.REGISTRY }} \
          --docker-username=${{ secrets.REGISTRY_USERNAME }} \
          --docker-password=${{ secrets.REGISTRY_PASSWORD }} \
          -n ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Generate Kubernetes manifests
      run: |
        mkdir -p k8s-manifests
        
        # Deployment manifest
        cat > k8s-manifests/deployment.yaml << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: blacklist
          namespace: ${{ env.NAMESPACE }}
          labels:
            app: blacklist
            environment: ${{ inputs.environment }}
        spec:
          replicas: ${{ env.REPLICAS }}
          selector:
            matchLabels:
              app: blacklist
          template:
            metadata:
              labels:
                app: blacklist
                environment: ${{ inputs.environment }}
            spec:
              imagePullSecrets:
                - name: registry-secret
              containers:
                - name: blacklist
                  image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.image_tag }}
                  imagePullPolicy: Always
                  ports:
                    - containerPort: 2541
                      name: http
                  env:
                    - name: FLASK_ENV
                      value: "production"
                    - name: PORT
                      value: "2541"
                    - name: FORCE_DISABLE_COLLECTION
                      value: "${{ inputs.environment == 'production' && 'false' || 'true' }}"
                    - name: COLLECTION_ENABLED
                      value: "${{ inputs.environment == 'production' && 'true' || 'false' }}"
                    - name: DATABASE_URL
                      value: "sqlite:////app/instance/blacklist.db"
                    - name: REDIS_URL
                      value: "redis://redis:6379/0"
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: http
                    initialDelaySeconds: 30
                    periodSeconds: 30
                    failureThreshold: 3
                  readinessProbe:
                    httpGet:
                      path: /ready
                      port: http
                    initialDelaySeconds: 5
                    periodSeconds: 10
                    failureThreshold: 3
                  resources:
                    limits:
                      cpu: ${{ env.RESOURCES_LIMITS_CPU }}
                      memory: ${{ env.RESOURCES_LIMITS_MEMORY }}
                    requests:
                      cpu: 100m
                      memory: 128Mi
                  volumeMounts:
                    - name: data
                      mountPath: /app/instance
                    - name: logs
                      mountPath: /app/logs
              volumes:
                - name: data
                  persistentVolumeClaim:
                    claimName: blacklist-data
                - name: logs
                  persistentVolumeClaim:
                    claimName: blacklist-logs
        EOF

        # Service manifest
        cat > k8s-manifests/service.yaml << EOF
        apiVersion: v1
        kind: Service
        metadata:
          name: blacklist
          namespace: ${{ env.NAMESPACE }}
          labels:
            app: blacklist
        spec:
          selector:
            app: blacklist
          ports:
            - port: 80
              targetPort: 2541
              protocol: TCP
              name: http
          type: ClusterIP
        EOF

        # Ingress manifest
        cat > k8s-manifests/ingress.yaml << EOF
        apiVersion: networking.k8s.io/v1
        kind: Ingress
        metadata:
          name: blacklist
          namespace: ${{ env.NAMESPACE }}
          annotations:
            cert-manager.io/cluster-issuer: "letsencrypt-prod"
            nginx.ingress.kubernetes.io/ssl-redirect: "true"
            nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
        spec:
          ingressClassName: nginx
          tls:
            - hosts:
                - ${{ env.INGRESS_HOST }}
              secretName: blacklist-tls
          rules:
            - host: ${{ env.INGRESS_HOST }}
              http:
                paths:
                  - path: /
                    pathType: Prefix
                    backend:
                      service:
                        name: blacklist
                        port:
                          number: 80
        EOF

        # PVC manifests
        cat > k8s-manifests/pvc.yaml << EOF
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: blacklist-data
          namespace: ${{ env.NAMESPACE }}
        spec:
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 1Gi
        ---
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: blacklist-logs
          namespace: ${{ env.NAMESPACE }}
        spec:
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 500Mi
        EOF

    - name: Apply Kubernetes manifests
      run: |
        export KUBECONFIG=/tmp/kubeconfig
        
        # Apply in order
        kubectl apply -f k8s-manifests/pvc.yaml
        kubectl apply -f k8s-manifests/deployment.yaml
        kubectl apply -f k8s-manifests/service.yaml
        kubectl apply -f k8s-manifests/ingress.yaml

    - name: Wait for deployment
      run: |
        export KUBECONFIG=/tmp/kubeconfig
        kubectl rollout status deployment/blacklist -n ${{ env.NAMESPACE }} --timeout=600s

    - name: Verify deployment
      run: |
        export KUBECONFIG=/tmp/kubeconfig
        
        # Get deployment status
        kubectl get deployment blacklist -n ${{ env.NAMESPACE }}
        kubectl get pods -l app=blacklist -n ${{ env.NAMESPACE }}
        
        # Check pod readiness
        READY_PODS=$(kubectl get pods -l app=blacklist -n ${{ env.NAMESPACE }} -o jsonpath='{.items[*].status.conditions[?(@.type=="Ready")].status}' | grep -c "True" || echo "0")
        TOTAL_PODS=$(kubectl get pods -l app=blacklist -n ${{ env.NAMESPACE }} --no-headers | wc -l)
        
        echo "Ready pods: $READY_PODS/$TOTAL_PODS"
        
        if [ "$READY_PODS" -eq "$TOTAL_PODS" ] && [ "$TOTAL_PODS" -gt "0" ]; then
          echo "‚úÖ All pods are ready"
        else
          echo "‚ùå Some pods are not ready"
          kubectl describe pods -l app=blacklist -n ${{ env.NAMESPACE }}
          if [ "${{ inputs.force_deploy }}" != "true" ]; then
            exit 1
          fi
        fi

    - name: Test deployment health
      run: |
        export KUBECONFIG=/tmp/kubeconfig
        
        # Port forward for health check
        kubectl port-forward -n ${{ env.NAMESPACE }} svc/blacklist 8080:80 &
        PID=$!
        sleep 15
        
        # Health check
        if curl -f http://localhost:8080/health > /dev/null 2>&1; then
          echo "‚úÖ Deployment health check passed"
          
          # Get basic status
          echo "Application Status:"
          curl -s http://localhost:8080/health | jq '.' || echo "Health check successful but no JSON response"
        else
          echo "‚ùå Deployment health check failed"
          if [ "${{ inputs.force_deploy }}" != "true" ]; then
            kill $PID 2>/dev/null || true
            exit 1
          fi
        fi
        
        kill $PID 2>/dev/null || true

    - name: Update ArgoCD (if production)
      if: ${{ inputs.environment == 'production' }}
      run: |
        # Trigger ArgoCD sync for production environment
        curl -k -X POST \
          -H "Authorization: Bearer ${{ secrets.ARGOCD_TOKEN }}" \
          -H "Content-Type: application/json" \
          -d '{"prune": true, "dryRun": false}' \
          https://argo.jclee.me/api/v1/applications/blacklist/sync || echo "ArgoCD sync request sent"

  post-deployment:
    name: Post-deployment Actions
    runs-on: ubuntu-latest
    needs: deploy-to-environment
    if: ${{ always() && needs.deploy-to-environment.result == 'success' }}

    steps:
    - name: Run smoke tests
      run: |
        case "${{ inputs.environment }}" in
          development)
            ENDPOINT="https://blacklist-dev.jclee.me"
            ;;
          staging)
            ENDPOINT="https://blacklist-staging.jclee.me"
            ;;
          production)
            ENDPOINT="https://blacklist.jclee.me"
            ;;
        esac

        echo "Running smoke tests against $ENDPOINT"
        
        # Wait for ingress to be ready
        sleep 60
        
        # Basic health check
        if curl -f "$ENDPOINT/health" > /dev/null 2>&1; then
          echo "‚úÖ Public endpoint health check passed"
        else
          echo "‚ö†Ô∏è Public endpoint not yet accessible (DNS/TLS may be propagating)"
        fi

        # API endpoint check
        if curl -f "$ENDPOINT/api/health" > /dev/null 2>&1; then
          echo "‚úÖ API endpoint accessible"
        else
          echo "‚ö†Ô∏è API endpoint not yet accessible"
        fi

    - name: Deployment summary
      run: |
        echo "üöÄ Deployment Summary"
        echo "===================="
        echo "Environment: ${{ inputs.environment }}"
        echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ inputs.image_tag }}"
        echo "Namespace: ${{ env.NAMESPACE }}"
        echo "Endpoint: https://${{ env.INGRESS_HOST }}"
        echo "Status: ‚úÖ Successful"
        echo ""
        echo "Next steps:"
        echo "1. Monitor application logs"
        echo "2. Run integration tests"
        echo "3. Verify all features are working"
        if [ "${{ inputs.environment }}" = "production" ]; then
          echo "4. Check ArgoCD sync status"
        fi