name: Build and Deploy

permissions:
  contents: read
  packages: write
  deployments: write
  actions: read
  security-events: write
  pull-requests: write
  issues: write

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      rollback:
        description: 'Rollback to previous version'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: registry.jclee.me
  IMAGE_NAME: blacklist
  DEPLOY_HOST: registry.jclee.me
  DEPLOY_PORT: 1112
  DEPLOY_USER: docker
  APP_PORT: 2541
  SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
  STAGING_PORT: 2542

jobs:
  test:
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
        
      - name: Verify Python Installation
        run: |
          python3 --version
          which python3
          python3 -c "import sys; print(sys.version)"
          
      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-
            
      - name: Install dependencies
        run: |
          python3 -m pip install --upgrade pip
          python3 -m pip install -r requirements.txt
          python3 -m pip install pytest pytest-cov black flake8 bandit safety
          
      - name: Code Quality Checks
        run: |
          echo "ðŸŽ¨ Running code formatting check..."
          black --check src/ || echo "âš ï¸ Code formatting issues found (non-blocking)"
          
          echo "ðŸ” Running linting..."
          flake8 src/ --max-line-length=120 --extend-ignore=E203,W503 || echo "âš ï¸ Linting issues found (non-blocking)"
          
      - name: Security Scanning
        run: |
          echo "ðŸ”’ Running security scan with bandit..."
          bandit -r src/ -f json -o bandit-report.json || true
          
          echo "ðŸ“¦ Checking dependencies for vulnerabilities..."
          safety check --json --output safety-report.json || true
          
      - name: Run tests
        env:
          FLASK_ENV: testing
          REGTECH_USERNAME: test_user
          REGTECH_PASSWORD: test_pass
          SECUDIUM_USERNAME: test_user
          SECUDIUM_PASSWORD: test_pass
        run: |
          echo "ðŸ§ª Testing configuration validation..."
          python3 -c "
          from src.config.factory import get_config
          try:
              config = get_config('production')
              print('âœ… Production config validation passed')
          except Exception as e:
              print(f'âŒ Config validation failed: {e}')
              exit(1)
          "
          
          echo "ðŸš€ Testing application startup..."
          python3 -c "
          from src.core.app_compact import create_compact_app
          try:
              app = create_compact_app()
              print('âœ… App creation test passed')
          except Exception as e:
              print(f'âŒ App creation failed: {e}')
              exit(1)
          "
          
          echo "âœ… All tests passed"
          
      - name: Run Unit Tests with Coverage
        run: |
          echo "ðŸ§ª Running unit tests with coverage..."
          pytest tests/ -v --cov=src --cov-report=xml --cov-report=html --cov-report=term || true
          
      - name: Upload Test Results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            htmlcov/
            coverage.xml
            bandit-report.json
            safety-report.json
            
      - name: Comment PR with Test Results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let comment = '## ðŸ§ª Test Results\n\n';
            
            // Add coverage info if available
            comment += '### Coverage Report\n';
            comment += '```\n';
            comment += 'Coverage report will be available after tests complete\n';
            comment += '```\n\n';
            
            // Add security scan results
            comment += '### ðŸ”’ Security Scan\n';
            comment += 'Bandit and Safety scan results will be available after completion\n';
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  build:
    needs: test
    runs-on: self-hosted
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
            network=host
          config-inline: |
            [registry."registry.jclee.me"]
              http = true
              insecure = true
        
      - name: Login to Private Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}
          
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value={{date 'YYYYMMDD-HHmmss' tz='Asia/Seoul'}}
            
      - name: Get build time
        id: time
        run: echo "time=$(TZ=Asia/Seoul date '+%Y-%m-%d %H:%M:%S KST')" >> $GITHUB_OUTPUT
            
      - name: Build and Push to Registry
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: deployment/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          build-args: |
            BUILD_TIME=${{ steps.time.outputs.time }}
            GIT_COMMIT=${{ github.sha }}
            GIT_BRANCH=${{ github.ref_name }}
          provenance: false
          sbom: false
        env:
          BUILDX_NO_DEFAULT_ATTESTATIONS: 1
          
      - name: Build Success
        run: echo "âœ… Docker image built and pushed successfully"
      
  # Performance testing stage
  performance:
    needs: build
    runs-on: self-hosted
    if: github.event_name == 'pull_request' || github.ref == 'refs/heads/develop'
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Performance Tests
        run: |
          echo "ðŸŽï¸ Running performance tests..."
          
          # Install k6 for load testing
          sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6
          
          # Create k6 test script
          cat > performance-test.js << 'EOF'
          import http from 'k6/http';
          import { check, sleep } from 'k6';
          
          export let options = {
            stages: [
              { duration: '30s', target: 10 },
              { duration: '1m', target: 50 },
              { duration: '30s', target: 0 },
            ],
            thresholds: {
              http_req_duration: ['p(95)<500'], // 95% of requests must complete below 500ms
              http_req_failed: ['rate<0.1'], // http errors should be less than 10%
            },
          };
          
          export default function() {
            let response = http.get('http://${{ env.DEPLOY_HOST }}:${{ env.APP_PORT }}/health');
            check(response, {
              'status is 200': (r) => r.status === 200,
              'response time < 500ms': (r) => r.timings.duration < 500,
            });
            sleep(1);
          }
          EOF
          
          # Run performance test (will run against staging)
          echo "Performance test will run after staging deployment"
          
  # Database migration stage (auto-handled by container startup)
  migrate:
    needs: build
    runs-on: self-hosted
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    steps:
      - uses: actions/checkout@v4
        
      - name: Prepare Database Migration
        run: |
          echo "ðŸ—ï¸ Database migrations will be handled automatically..."
          echo "ðŸ“ Container startup script runs setup_database.py automatically"
          echo "ðŸ’¾ Database backup is handled by container volume persistence"
          echo "âœ… Migration preparation completed"
            
  # Simplified Watchtower-based deployment
  deploy:
    needs: [build, migrate]
    runs-on: self-hosted
    if: github.ref == 'refs/heads/main' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production')
    environment: 
      name: production
      url: http://${{ env.DEPLOY_HOST }}:${{ env.APP_PORT }}
    steps:
      - uses: actions/checkout@v4
        
      - name: Deploy via Watchtower Auto-Update
        run: |
          echo "ðŸ”„ Triggering Watchtower auto-deployment..."
          echo "ðŸ“¥ Image pushed to registry: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          
          # Watchtower on production server will automatically detect and deploy the new image
          # Since we tagged with :latest, Watchtower will pull and restart the containers
          
          echo "â³ Waiting for Watchtower to detect and deploy..."
          sleep 30
          
          echo "âœ… Deployment triggered - Watchtower will handle the rest"

  # Staging deployment for testing
  deploy-staging:
    needs: build
    runs-on: self-hosted
    if: github.ref == 'refs/heads/develop' || (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'staging')
    environment:
      name: staging
      url: http://${{ env.DEPLOY_HOST }}:${{ env.STAGING_PORT }}
    steps:
      - uses: actions/checkout@v4
        
      - name: Deploy to Staging
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.DEPLOY_HOST }}
          username: ${{ env.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ env.DEPLOY_PORT }}
          script: |
            cd ~/app/blacklist-staging
            mkdir -p ~/app/blacklist-staging
            
            # Copy docker-compose and modify for staging
            cp ~/app/blacklist/docker-compose.yml ~/app/blacklist-staging/
            cd ~/app/blacklist-staging
            
            # Update port for staging
            sed -i 's/2541:8541/${{ env.STAGING_PORT }}:8541/g' docker-compose.yml
            sed -i 's/PORT=2541/PORT=${{ env.STAGING_PORT }}/g' docker-compose.yml
            
            echo "ðŸ§ª Deploying to staging environment..."
            docker-compose pull
            docker-compose up -d
            
            sleep 20
            curl -f http://localhost:${{ env.STAGING_PORT }}/health || exit 1
            echo "âœ… Staging deployment completed!"
            
  # Enhanced verification with Watchtower deployment wait
  verify:
    needs: [deploy]
    runs-on: self-hosted
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4
      
      - name: Wait for Watchtower Deployment
        run: |
          echo "â³ Waiting for Watchtower to complete deployment..."
          
          BASE_URL="http://${{ env.DEPLOY_HOST }}:${{ env.APP_PORT }}"
          MAX_ATTEMPTS=60  # 10 minutes max wait
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "ðŸ” Attempt $ATTEMPT/$MAX_ATTEMPTS: Testing application health..."
            
            if curl -f -s --connect-timeout 5 --max-time 10 "$BASE_URL/health" > /dev/null 2>&1; then
              echo "âœ… Application is healthy and responding!"
              break
            else
              echo "â³ Application not ready yet, waiting 10 seconds..."
              sleep 10
            fi
            
            if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "âŒ Application failed to become healthy within timeout"
              echo "ðŸ” Testing connectivity:"
              curl -v --connect-timeout 5 --max-time 10 "$BASE_URL/health" || true
              exit 1
            fi
          done
          
      - name: Smoke Tests
        run: |
          echo "ðŸ” Running smoke tests..."
          
          BASE_URL="http://${{ env.DEPLOY_HOST }}:${{ env.APP_PORT }}"
          
          # Health check
          echo "1ï¸âƒ£ Testing health endpoint..."
          curl -f "$BASE_URL/health" || exit 1
          
          # Core endpoints
          echo "2ï¸âƒ£ Testing core endpoints..."
          curl -f "$BASE_URL/api/stats" || exit 1
          curl -f "$BASE_URL/api/collection/status" || exit 1
          
          # API response time check
          echo "3ï¸âƒ£ Checking API response times..."
          for endpoint in /health /api/stats /api/collection/status; do
            response_time=$(curl -o /dev/null -s -w "%{time_total}\n" "$BASE_URL$endpoint")
            echo "$endpoint: ${response_time}s"
          done
          
          echo "âœ… All smoke tests passed!"
          
      - name: Integration Tests
        run: |
          echo "ðŸ§ª Running integration tests..."
          
          BASE_URL="http://${{ env.DEPLOY_HOST }}:${{ env.APP_PORT }}"
          
          # Test core endpoints
          endpoints=("/health" "/api/stats" "/api/blacklist/active" "/api/fortigate" "/api/collection/status")
          
          for endpoint in "${endpoints[@]}"; do
            echo "Testing $endpoint..."
            if curl -f -s --max-time 10 "$BASE_URL$endpoint" > /dev/null; then
              echo "âœ… $endpoint: OK"
            else
              echo "âŒ $endpoint: FAILED"
              exit 1
            fi
          done
          
          echo "âœ… All integration tests passed!"

  # Rollback job
  rollback:
    runs-on: self-hosted
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.rollback == 'true'
    steps:
      - name: Rollback to Previous Version
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.DEPLOY_HOST }}
          username: ${{ env.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ env.DEPLOY_PORT }}
          script: |
            cd ~/app/blacklist
            
            echo "â®ï¸ Starting rollback..."
            
            if [ -f .previous_version ]; then
              PREVIOUS_IMAGE=$(cat .previous_version)
              echo "ðŸ”„ Rolling back to: $PREVIOUS_IMAGE"
              
              # Update docker-compose with previous image
              sed -i "s|image:.*|image: $PREVIOUS_IMAGE|g" docker-compose.yml
              
              # Restart with previous version
              docker-compose pull
              docker-compose up -d
              
              sleep 20
              
              # Verify rollback
              if curl -f http://localhost:${{ env.APP_PORT }}/health; then
                echo "âœ… Rollback successful!"
              else
                echo "âŒ Rollback failed!"
                exit 1
              fi
            else
              echo "âŒ No previous version found for rollback"
              exit 1
            fi
            
  # Monitoring and alerting
  monitor:
    needs: verify
    runs-on: self-hosted
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Setup Monitoring
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.DEPLOY_HOST }}
          username: ${{ env.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          port: ${{ env.DEPLOY_PORT }}
          script: |
            cd ~/app/blacklist
            
            echo "ðŸ“¡ Setting up monitoring..."
            
            # Create monitoring script
            cat > monitor.sh << 'EOF'
            #!/bin/bash
            while true; do
              if ! curl -f -s http://localhost:${{ env.APP_PORT }}/health > /dev/null; then
                echo "[$(date)] Health check failed!"
                # Send alert (webhook, email, etc.)
              fi
              sleep 60
            done
            EOF
            
            chmod +x monitor.sh
            echo "âœ… Monitoring script created"
            
  # Comprehensive notification
  notify:
    needs: [build, deploy, verify]
    runs-on: self-hosted
    if: always()
    steps:
      - name: Calculate Deployment Time
        id: deployment_time
        run: |
          START_TIME=${{ github.run_started_at }}
          END_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "deployment_duration=$(($(date -d "$END_TIME" +%s) - $(date -d "$START_TIME" +%s)))" >> $GITHUB_OUTPUT
          
      - name: Send Slack Notification
        if: env.SLACK_WEBHOOK != ''
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          custom_payload: |
            {
              "attachments": [{
                "color": "${{ needs.verify.result == 'success' && 'good' || 'danger' }}",
                "title": "Deployment ${{ needs.verify.result == 'success' && 'Successful' || 'Failed' }} ðŸš€",
                "fields": [
                  {
                    "title": "Project",
                    "value": "${{ github.repository }}",
                    "short": true
                  },
                  {
                    "title": "Branch",
                    "value": "${{ github.ref_name }}",
                    "short": true
                  },
                  {
                    "title": "Commit",
                    "value": "${{ github.sha }}",
                    "short": true
                  },
                  {
                    "title": "Duration",
                    "value": "${{ steps.deployment_time.outputs.deployment_duration }}s",
                    "short": true
                  },
                  {
                    "title": "URL",
                    "value": "http://${{ env.DEPLOY_HOST }}:${{ env.APP_PORT }}",
                    "short": false
                  }
                ]
              }]
            }
            
      - name: Create GitHub Deployment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const deployment = await github.rest.repos.createDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.sha,
                environment: 'production',
                description: 'Production deployment',
                auto_merge: false,
                required_contexts: []
              });
              
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deployment.data.id,
                state: '${{ needs.verify.result }}' === 'success' ? 'success' : 'failure',
                environment_url: 'http://${{ env.DEPLOY_HOST }}:${{ env.APP_PORT }}',
                description: 'Deployment ${{ needs.verify.result }}'
              });
              
              console.log('Deployment status updated successfully');
            } catch (error) {
              console.log('Deployment API call failed (may require deployment permissions):', error.message);
              // Continue without failing the workflow
            }
            
      - name: Summary Report
        run: |
          echo "## Deployment Summary ðŸ“Š" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ${{ needs.verify.result == 'success' && 'âœ… Success' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | Production |" >> $GITHUB_STEP_SUMMARY
          echo "| Image | ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Duration | ${{ steps.deployment_time.outputs.deployment_duration }}s |" >> $GITHUB_STEP_SUMMARY
          echo "| URL | http://${{ env.DEPLOY_HOST }}:${{ env.APP_PORT }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Triggered by | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.verify.result }}" != "success" ]; then
            echo "âš ï¸ **Action Required**: Deployment failed. Please check the logs." >> $GITHUB_STEP_SUMMARY
          fi