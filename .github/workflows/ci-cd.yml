name: Optimized GitOps Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: registry.jclee.me
  IMAGE_NAME: jclee94/blacklist
  PYTHON_VERSION: '3.11'

jobs:
  quality-and-test:
    name: Quality Gate & Testing
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov pytest-mock black isort flake8 bandit safety

    - name: Code quality checks (non-blocking)
      run: |
        echo "🔍 Running code quality checks..."
        
        # Format check (warning only)
        if ! black --check src/ tests/; then
          echo "⚠️ Code formatting issues found - consider running 'black src/ tests/'"
        else
          echo "✅ Code formatting looks good"
        fi
        
        # Import sorting (warning only)  
        if ! isort --check-only src/ tests/; then
          echo "⚠️ Import sorting issues found - consider running 'isort src/ tests/'"
        else
          echo "✅ Import sorting looks good"
        fi
        
        # Critical syntax errors only
        echo "🔎 Checking for critical syntax errors..."
        flake8 src/ --count --select=E9,F63,F7,F82 --show-source --statistics
        
        # Style guide (warnings only, exit 0)
        echo "📏 Style guide compliance check..."
        flake8 src/ --count --max-line-length=88 --extend-ignore=E203,W503 --statistics --exit-zero

    - name: File size advisory (non-blocking)
      run: |
        echo "📊 Checking file sizes (advisory - 500 line recommendation)..."
        LARGE_FILES=$(find src/ -name "*.py" -exec wc -l {} + | awk '$1 > 500 { print "⚠️ " $2 " has " $1 " lines (consider splitting)"; count++ } END { print count+0 }')
        LARGE_COUNT=$(echo "$LARGE_FILES" | tail -1)
        
        if [ "$LARGE_COUNT" -gt 0 ]; then
          echo "$LARGE_FILES" | head -n -1
          echo "💡 Consider breaking down large files for better maintainability"
        else
          echo "✅ All files within recommended 500 line limit"
        fi

    - name: Security scan (advisory)
      run: |
        echo "🛡️ Running security scans..."
        
        # Bandit security scan (advisory)
        if bandit -r src/ -ll -f json -o bandit-report.json; then
          echo "✅ No high-level security issues found"
        else
          echo "⚠️ Security scan completed with warnings - check bandit-report.json"
        fi
        
        # Safety dependency check (advisory)
        if safety check --json --output safety-report.json; then
          echo "✅ No known vulnerabilities in dependencies"  
        else
          echo "⚠️ Dependency scan completed with warnings - check safety-report.json"
        fi

    - name: Run core tests
      run: |
        echo "🧪 Running test suite..."
        python -m pytest tests/ -v \
          --cov=src \
          --cov-report=xml \
          --cov-report=term-missing \
          --maxfail=3 \
          -m "not slow"
      env:
        FLASK_ENV: testing
        FORCE_DISABLE_COLLECTION: true
        COLLECTION_ENABLED: false

    - name: Upload coverage (optional)
      uses: codecov/codecov-action@v3
      if: success()
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

  build-and-security:
    name: Build & Security Scan
    runs-on: ubuntu-latest
    needs: quality-and-test
    if: github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    timeout-minutes: 20
    permissions:
      contents: read
      packages: write
      security-events: write

    outputs:
      image: ${{ steps.meta.outputs.tags }}
      digest: ${{ steps.build.outputs.digest }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry  
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.REGISTRY_USERNAME }}
        password: ${{ secrets.REGISTRY_PASSWORD }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-,format=short
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

    - name: Run Trivy filesystem scan
      uses: aquasecurity/trivy-action@master
      continue-on-error: true
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-fs-results.sarif'

    - name: Run Trivy container scan
      uses: aquasecurity/trivy-action@master
      continue-on-error: true
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        format: 'sarif'
        output: 'trivy-image-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      continue-on-error: true
      with:
        sarif_file: 'trivy-fs-results.sarif'

    - name: Upload Trivy image scan results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      continue-on-error: true
      with:
        sarif_file: 'trivy-image-results.sarif'

  deploy:
    name: GitOps Deployment
    runs-on: ubuntu-latest
    needs: build-and-security
    if: github.ref == 'refs/heads/main'
    timeout-minutes: 10
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'

    - name: Configure kubectl
      run: |
        echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > /tmp/kubeconfig
        export KUBECONFIG=/tmp/kubeconfig
        kubectl cluster-info

    - name: Create namespace and secrets
      run: |
        export KUBECONFIG=/tmp/kubeconfig
        kubectl create namespace blacklist || true
        
        # Create registry secret
        kubectl create secret docker-registry registry-secret \
          --docker-server=${{ env.REGISTRY }} \
          --docker-username=${{ secrets.REGISTRY_USERNAME }} \
          --docker-password=${{ secrets.REGISTRY_PASSWORD }} \
          -n blacklist --dry-run=client -o yaml | kubectl apply -f -

    - name: Generate optimized K8s manifests
      run: |
        mkdir -p k8s-deploy
        
        # Simple deployment with the latest image
        cat > k8s-deploy/deployment.yaml << EOF
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: blacklist
          namespace: blacklist
          labels:
            app: blacklist
            version: "$(echo '${{ needs.build-and-security.outputs.digest }}' | cut -c8-15)"
        spec:
          replicas: 2
          selector:
            matchLabels:
              app: blacklist
          template:
            metadata:
              labels:
                app: blacklist
            spec:
              imagePullSecrets:
                - name: registry-secret
              containers:
                - name: blacklist
                  image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
                  imagePullPolicy: Always
                  ports:
                    - containerPort: 2541
                      name: http
                  env:
                    - name: FLASK_ENV
                      value: "production"
                    - name: PORT
                      value: "2541"
                    - name: FORCE_DISABLE_COLLECTION
                      value: "false"
                    - name: COLLECTION_ENABLED
                      value: "true"
                    - name: DATABASE_URL
                      value: "sqlite:////app/instance/blacklist.db"
                  livenessProbe:
                    httpGet:
                      path: /health
                      port: http
                    initialDelaySeconds: 30
                    periodSeconds: 30
                  readinessProbe:
                    httpGet:
                      path: /health
                      port: http
                    initialDelaySeconds: 5
                    periodSeconds: 10
                  resources:
                    limits:
                      cpu: 500m
                      memory: 512Mi
                    requests:
                      cpu: 100m
                      memory: 128Mi
                  volumeMounts:
                    - name: data
                      mountPath: /app/instance
              volumes:
                - name: data
                  persistentVolumeClaim:
                    claimName: blacklist-data
        EOF

        # Service
        cat > k8s-deploy/service.yaml << EOF
        apiVersion: v1
        kind: Service
        metadata:
          name: blacklist
          namespace: blacklist
        spec:
          selector:
            app: blacklist
          ports:
            - port: 80
              targetPort: 2541
              protocol: TCP
        EOF

        # PVC for data persistence
        cat > k8s-deploy/pvc.yaml << EOF
        apiVersion: v1
        kind: PersistentVolumeClaim
        metadata:
          name: blacklist-data
          namespace: blacklist
        spec:
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 1Gi
        EOF

    - name: Apply manifests with rollback capability
      run: |
        export KUBECONFIG=/tmp/kubeconfig
        
        # Store current deployment for potential rollback
        kubectl get deployment blacklist -n blacklist -o yaml > /tmp/current-deployment.yaml 2>/dev/null || echo "No existing deployment"
        
        # Apply manifests
        kubectl apply -f k8s-deploy/pvc.yaml
        kubectl apply -f k8s-deploy/service.yaml
        
        # Deploy with automatic rollback on failure
        if kubectl apply -f k8s-deploy/deployment.yaml; then
          echo "✅ Deployment manifest applied successfully"
        else
          echo "❌ Deployment manifest failed to apply"
          exit 1
        fi

    - name: Wait for rollout and verify
      run: |
        export KUBECONFIG=/tmp/kubeconfig
        
        # Wait for rollout with timeout
        if kubectl rollout status deployment/blacklist -n blacklist --timeout=300s; then
          echo "✅ Deployment rollout completed successfully"
        else
          echo "❌ Deployment rollout failed"
          
          # Auto-rollback if previous version exists
          if [ -f /tmp/current-deployment.yaml ]; then
            echo "🔄 Attempting automatic rollback..."
            kubectl apply -f /tmp/current-deployment.yaml
            kubectl rollout status deployment/blacklist -n blacklist --timeout=180s
          fi
          exit 1
        fi
        
        # Verify pods are healthy
        READY_PODS=$(kubectl get pods -l app=blacklist -n blacklist -o jsonpath='{.items[*].status.conditions[?(@.type=="Ready")].status}' | grep -c "True" || echo "0")
        TOTAL_PODS=$(kubectl get pods -l app=blacklist -n blacklist --no-headers | wc -l)
        
        echo "Pod status: $READY_PODS/$TOTAL_PODS ready"
        
        if [ "$READY_PODS" -eq "$TOTAL_PODS" ] && [ "$TOTAL_PODS" -gt "0" ]; then
          echo "✅ All pods are healthy"
        else
          echo "❌ Pod health check failed"
          kubectl describe pods -l app=blacklist -n blacklist
          exit 1
        fi

    - name: Health check and ArgoCD sync
      run: |
        export KUBECONFIG=/tmp/kubeconfig
        
        # Internal health check via port-forward
        kubectl port-forward -n blacklist svc/blacklist 8080:80 &
        PID=$!
        sleep 10
        
        if curl -f http://localhost:8080/health > /dev/null 2>&1; then
          echo "✅ Internal health check passed"
          
          # Trigger ArgoCD sync
          echo "🔄 Triggering ArgoCD sync..."
          curl -k -X POST \
            -H "Authorization: Bearer ${{ secrets.ARGOCD_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{"prune": false, "dryRun": false}' \
            https://argo.jclee.me/api/v1/applications/blacklist/sync || echo "⚠️ ArgoCD sync request sent (may be optional)"
        else
          echo "❌ Health check failed"
          kill $PID 2>/dev/null || true
          exit 1
        fi
        
        kill $PID 2>/dev/null || true

  notify:
    name: Deployment Status
    runs-on: ubuntu-latest
    needs: [quality-and-test, build-and-security, deploy]
    if: always()

    steps:
    - name: Deployment summary
      run: |
        echo "🔄 GitOps Pipeline Summary"
        echo "========================="
        echo ""
        echo "📊 Stage Results:"
        echo "- Quality & Test: ${{ needs.quality-and-test.result }}"
        echo "- Build & Security: ${{ needs.build-and-security.result }}"  
        echo "- Deploy: ${{ needs.deploy.result }}"
        echo ""
        
        if [ "${{ needs.deploy.result }}" = "success" ]; then
          echo "🎉 Deployment Successful!"
          echo "✅ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          echo "✅ Application: https://blacklist.jclee.me"
          echo "✅ ArgoCD: https://argo.jclee.me/applications/blacklist"
          echo ""
          echo "🔗 Quick Links:"
          echo "- Health Check: https://blacklist.jclee.me/health"
          echo "- API Status: https://blacklist.jclee.me/api/health" 
          echo "- FortiGate Feed: https://blacklist.jclee.me/api/fortigate"
          echo ""
          echo "📈 Performance Metrics:"
          echo "- Target Response Time: <50ms"
          echo "- Expected Uptime: >99.9%"
          echo "- Auto-scaling: Enabled (2-10 replicas)"
        elif [ "${{ needs.quality-and-test.result }}" = "failure" ]; then
          echo "❌ Quality Gate Failed"
          echo "🔍 Check test results and code quality issues"
        elif [ "${{ needs.build-and-security.result }}" = "failure" ]; then
          echo "❌ Build or Security Scan Failed"
          echo "🛡️ Check Docker build and Trivy scan results"
        elif [ "${{ needs.deploy.result }}" = "failure" ]; then
          echo "❌ Deployment Failed"
          echo "🔧 Check Kubernetes deployment and ArgoCD status"
        else
          echo "⚠️ Pipeline completed with issues"
          echo "📋 Review individual job logs for details"
        fi