name: Deployment Health Monitor

on:
  workflow_run:
    workflows: ["Enhanced Kubernetes CI/CD Pipeline"]
    types:
      - completed
  schedule:
    # Îß§ ÏãúÍ∞Ñ Ïã§ÌñâÌïòÏó¨ ÏûêÎèô Î∞∞Ìè¨ ÏÉÅÌÉú Ï≤¥ÌÅ¨
    - cron: '0 * * * *'
  workflow_dispatch:

env:
  NAMESPACE: blacklist
  REGISTRY: registry.jclee.me
  IMAGE_NAME: blacklist

jobs:
  check-deployment-health:
    runs-on: self-hosted
    steps:
      - name: Check Registry Authentication
        run: |
          echo "üîê Testing Docker Registry authentication..."
          
          # Registry Ïù∏Ï¶ù ÌÖåÏä§Ìä∏
          if echo "${{ secrets.DOCKER_PASSWORD }}" | docker login registry.jclee.me -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin; then
            echo "‚úÖ Registry authentication successful"
          else
            echo "‚ùå Registry authentication failed!"
            echo "::error::Docker Registry authentication failed. Please check DOCKER_USERNAME and DOCKER_PASSWORD secrets."
            exit 1
          fi

      - name: Check GitHub Secrets
        run: |
          echo "üîë Checking required secrets..."
          
          MISSING_SECRETS=""
          
          # Required secrets Ï≤¥ÌÅ¨
          [ -z "${{ secrets.DOCKER_USERNAME }}" ] && MISSING_SECRETS="$MISSING_SECRETS DOCKER_USERNAME"
          [ -z "${{ secrets.DOCKER_PASSWORD }}" ] && MISSING_SECRETS="$MISSING_SECRETS DOCKER_PASSWORD"
          [ -z "${{ secrets.REGISTRY_USERNAME }}" ] && MISSING_SECRETS="$MISSING_SECRETS REGISTRY_USERNAME"
          [ -z "${{ secrets.REGISTRY_PASSWORD }}" ] && MISSING_SECRETS="$MISSING_SECRETS REGISTRY_PASSWORD"
          
          if [ -n "$MISSING_SECRETS" ]; then
            echo "‚ùå Missing secrets:$MISSING_SECRETS"
            echo "::error::Missing required secrets:$MISSING_SECRETS"
            exit 1
          else
            echo "‚úÖ All required secrets are configured"
          fi

      - name: Check Kubernetes Connectivity
        run: |
          echo "‚ò∏Ô∏è Checking Kubernetes cluster connectivity..."
          
          # Kubernetes Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
          if kubectl get nodes --no-headers > /dev/null 2>&1; then
            echo "‚úÖ Kubernetes cluster is accessible"
            kubectl get nodes
          else
            echo "‚ùå Cannot connect to Kubernetes cluster"
            echo "::error::Kubernetes cluster is not accessible"
            exit 1
          fi

      - name: Check Deployment Status
        id: deployment_check
        run: |
          echo "üöÄ Checking deployment status..."
          
          # Deployment ÏÉÅÌÉú ÌôïÏù∏
          if kubectl get deployment blacklist -n ${{ env.NAMESPACE }} > /dev/null 2>&1; then
            echo "‚úÖ Deployment exists"
            
            # ÌòÑÏû¨ Ïù¥ÎØ∏ÏßÄ ÌôïÏù∏
            CURRENT_IMAGE=$(kubectl get deployment blacklist -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.template.spec.containers[0].image}')
            echo "Current image: $CURRENT_IMAGE"
            echo "current_image=$CURRENT_IMAGE" >> $GITHUB_OUTPUT
            
            # Ready replicas ÌôïÏù∏
            READY_REPLICAS=$(kubectl get deployment blacklist -n ${{ env.NAMESPACE }} -o jsonpath='{.status.readyReplicas}')
            DESIRED_REPLICAS=$(kubectl get deployment blacklist -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.replicas}')
            
            echo "Ready replicas: $READY_REPLICAS/$DESIRED_REPLICAS"
            
            if [ "$READY_REPLICAS" != "$DESIRED_REPLICAS" ]; then
              echo "‚ö†Ô∏è Not all replicas are ready"
              echo "deployment_healthy=false" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ All replicas are ready"
              echo "deployment_healthy=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ùå Deployment not found"
            echo "deployment_healthy=false" >> $GITHUB_OUTPUT
          fi

      - name: Check Latest Image in Registry
        id: registry_check
        run: |
          echo "üì¶ Checking latest image in registry..."
          
          # RegistryÏóêÏÑú ÏµúÏã† Ïù¥ÎØ∏ÏßÄ ÌÉúÍ∑∏ ÌôïÏù∏ (curl ÏÇ¨Ïö©)
          REGISTRY_URL="https://registry.jclee.me/v2/${{ env.IMAGE_NAME }}/tags/list"
          
          # Basic auth header ÏÉùÏÑ±
          AUTH=$(echo -n "${{ secrets.REGISTRY_USERNAME }}:${{ secrets.REGISTRY_PASSWORD }}" | base64)
          
          # Tags Í∞ÄÏ†∏Ïò§Í∏∞
          TAGS_RESPONSE=$(curl -s -H "Authorization: Basic $AUTH" "$REGISTRY_URL" || echo "{}")
          
          if echo "$TAGS_RESPONSE" | grep -q "tags"; then
            echo "‚úÖ Successfully retrieved tags from registry"
            # ÏµúÏã† ÌÉúÍ∑∏ Ï∞æÍ∏∞ (timestamp Í∏∞Î∞ò)
            LATEST_TAG=$(echo "$TAGS_RESPONSE" | grep -o '"[0-9]\{8\}-[0-9]\{6\}"' | sort -r | head -1 | tr -d '"')
            if [ -n "$LATEST_TAG" ]; then
              echo "Latest timestamp tag: $LATEST_TAG"
              echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è Could not retrieve tags from registry"
          fi

      - name: Check Service Health
        run: |
          echo "üè• Checking service health..."
          
          # NodePort ÏÑúÎπÑÏä§ ÌôïÏù∏
          NODE_PORT=$(kubectl get svc blacklist-nodeport -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "")
          
          if [ -n "$NODE_PORT" ]; then
            NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
            HEALTH_URL="http://$NODE_IP:$NODE_PORT/health"
            
            echo "Testing health endpoint: $HEALTH_URL"
            
            if curl -f -s --connect-timeout 5 --max-time 10 "$HEALTH_URL" > /dev/null 2>&1; then
              echo "‚úÖ Health check passed"
            else
              echo "‚ùå Health check failed"
              echo "::warning::Service health check failed"
            fi
          else
            echo "‚ö†Ô∏è NodePort service not found"
          fi

      - name: Check Auto-updater CronJob
        run: |
          echo "‚è∞ Checking auto-updater CronJob..."
          
          # CronJob Ï°¥Ïû¨ ÌôïÏù∏
          if kubectl get cronjob -n ${{ env.NAMESPACE }} | grep -q "auto-updater"; then
            echo "‚úÖ Auto-updater CronJob exists"
            
            # ÏµúÍ∑º Ïã§Ìñâ ÌôïÏù∏
            LAST_SCHEDULE=$(kubectl get cronjob -n ${{ env.NAMESPACE }} -o jsonpath='{.items[?(@.metadata.name=="auto-updater")].status.lastScheduleTime}' 2>/dev/null || echo "")
            
            if [ -n "$LAST_SCHEDULE" ]; then
              echo "Last scheduled: $LAST_SCHEDULE"
            else
              echo "‚ö†Ô∏è CronJob has never been scheduled"
            fi
            
            # Job Ïã§Ìñâ Ïù¥Î†• ÌôïÏù∏
            echo "Recent jobs:"
            kubectl get jobs -n ${{ env.NAMESPACE }} --sort-by='.metadata.creationTimestamp' | grep "auto-updater" | tail -5 || echo "No recent jobs"
          else
            echo "‚ùå Auto-updater CronJob not found"
            echo "::warning::Auto-updater CronJob is missing"
            
            # CronJob ÏÉùÏÑ± ÏãúÎèÑ
            echo "Attempting to create auto-updater CronJob..."
            if [ -f "k8s/auto-updater.yaml" ]; then
              kubectl apply -f k8s/auto-updater.yaml
              echo "‚úÖ Auto-updater CronJob created"
            else
              echo "‚ö†Ô∏è auto-updater.yaml not found"
            fi
          fi

      - name: Generate Health Report
        if: always()
        run: |
          echo "## üè• Deployment Health Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìä Health Check Results" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Docker Registry Auth | ${{ steps.deployment_check.outcome == 'success' && '‚úÖ OK' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| GitHub Secrets | ${{ steps.deployment_check.outcome == 'success' && '‚úÖ OK' || '‚ùå Missing' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Kubernetes Access | ${{ steps.deployment_check.outcome == 'success' && '‚úÖ OK' || '‚ùå Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployment Status | ${{ steps.deployment_check.outputs.deployment_healthy == 'true' && '‚úÖ Healthy' || '‚ö†Ô∏è Unhealthy' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Service Health | ‚úÖ OK |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.deployment_check.outputs.deployment_healthy }}" != "true" ]; then
            echo "### ‚ö†Ô∏è Action Required" >> $GITHUB_STEP_SUMMARY
            echo "The deployment is not in a healthy state. Please check:" >> $GITHUB_STEP_SUMMARY
            echo "- Pod logs: `kubectl logs -n blacklist deployment/blacklist`" >> $GITHUB_STEP_SUMMARY
            echo "- Pod events: `kubectl describe pods -n blacklist -l app=blacklist`" >> $GITHUB_STEP_SUMMARY
            echo "- Recent events: `kubectl get events -n blacklist --sort-by='.lastTimestamp'`" >> $GITHUB_STEP_SUMMARY
          fi

  auto-fix-common-issues:
    needs: check-deployment-health
    runs-on: self-hosted
    if: failure()
    steps:
      - name: Attempt Auto-fix
        run: |
          echo "üîß Attempting to auto-fix common issues..."
          
          # PVC Î¨∏Ï†ú ÏûêÎèô ÏàòÏ†ï
          echo "Checking PVC status..."
          PENDING_PVCS=$(kubectl get pvc -n ${{ env.NAMESPACE }} -o json | jq -r '.items[] | select(.status.phase=="Pending") | .metadata.name')
          
          if [ -n "$PENDING_PVCS" ]; then
            echo "Found pending PVCs: $PENDING_PVCS"
            echo "Attempting to fix PV bindings..."
            
            # PV ÏÉÅÌÉú ÌôïÏù∏ Î∞è ÏàòÏ†ï
            for PVC in $PENDING_PVCS; do
              PV_NAME="${PVC}-pv"
              if kubectl get pv "$PV_NAME" > /dev/null 2>&1; then
                echo "Patching PV $PV_NAME..."
                kubectl patch pv "$PV_NAME" -p '{"spec":{"claimRef": null}}'
              fi
            done
            
            # PVC Ïû¨ÏÉùÏÑ±
            kubectl delete pvc $PENDING_PVCS -n ${{ env.NAMESPACE }} --force --grace-period=0
            sleep 5
            kubectl apply -k k8s/
          fi
          
          # Deployment Ïû¨ÏãúÏûë
          echo "Restarting deployment..."
          kubectl rollout restart deployment/blacklist -n ${{ env.NAMESPACE }}
          kubectl rollout status deployment/blacklist -n ${{ env.NAMESPACE }} --timeout=300s
          
          echo "‚úÖ Auto-fix completed"

      - name: Send Alert
        if: failure()
        run: |
          echo "üö® Sending deployment failure alert..."
          
          # Slack/Discord/Email ÏïåÎ¶º (webhook URLÏù¥ ÏÑ§Ï†ïÎêú Í≤ΩÏö∞)
          if [ -n "${{ secrets.ALERT_WEBHOOK_URL }}" ]; then
            curl -X POST "${{ secrets.ALERT_WEBHOOK_URL }}" \
              -H "Content-Type: application/json" \
              -d '{
                "text": "üö® Blacklist Deployment Issue Detected",
                "blocks": [
                  {
                    "type": "section",
                    "text": {
                      "type": "mrkdwn",
                      "text": "*Deployment Health Check Failed*\n‚Ä¢ Repository: ${{ github.repository }}\n‚Ä¢ Workflow: ${{ github.workflow }}\n‚Ä¢ Run: ${{ github.run_id }}"
                    }
                  }
                ]
              }'
          fi