name: GitOps Pipeline

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '*.txt'
      - 'LICENSE'
      - '.gitignore'
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# 동시 실행 제어
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ${{ secrets.REGISTRY_URL || 'registry.jclee.me' }}
  IMAGE_NAME: blacklist
  PYTHON_VERSION: '3.11'
  HELM_VERSION: 'v3.12.0'
  CHARTMUSEUM_URL: ${{ secrets.CHARTMUSEUM_URL || 'https://charts.jclee.me' }}

jobs:
  # 0. 이전 실행 취소
  cancel-previous:
    runs-on: self-hosted
    steps:
      - name: Cancel Previous Runs
        uses: styfle/cancel-workflow-action@0.12.1
        with:
          access_token: ${{ github.token }}

  # 1. 코드 품질 검사 (병렬 실행)
  quality-check:
    runs-on: self-hosted
    needs: cancel-previous
    strategy:
      fail-fast: false
      matrix:
        check-type: [lint, security]
    outputs:
      quality-passed: ${{ steps.combine.outputs.passed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip packages
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          
          if [[ "${{ matrix.check-type }}" == "lint" ]]; then
            pip install flake8 black isort mypy
          else
            pip install bandit safety semgrep
          fi

      - name: Run ${{ matrix.check-type }} checks
        id: check
        run: |
          echo "Running ${{ matrix.check-type }} checks..."
          
          if [[ "${{ matrix.check-type }}" == "lint" ]]; then
            # Linting checks
            flake8 src/ --max-line-length=88 --extend-ignore=E203,W503,W293,W291,E501,E302 --exit-zero
            black --check src/ --diff || echo "⚠️ Black formatting issues found (non-blocking)"
            isort src/ --check-only --diff || echo "⚠️ Import sorting issues found (non-blocking)"
            mypy src/ --ignore-missing-imports --no-error-summary || echo "⚠️ Type checking issues found (non-blocking)"
          else
            # Security checks
            bandit -r src/ -ll || echo "⚠️ Security issues found (non-blocking)"
            safety check || echo "⚠️ Dependency vulnerabilities found (non-blocking)"
            # semgrep --config=auto src/ || echo "⚠️ Semgrep issues found (non-blocking)"
          fi
          
          echo "check_passed=true" >> $GITHUB_OUTPUT

      - name: Combine results
        if: always()
        id: combine
        run: |
          # All quality checks are non-blocking, so always pass
          echo "passed=true" >> $GITHUB_OUTPUT

  # 2. 테스트 (병렬 실행)
  test:
    runs-on: self-hosted
    needs: quality-check
    if: needs.quality-check.outputs.quality-passed == 'true'
    strategy:
      fail-fast: false
      matrix:
        test-suite: [unit, integration]
    outputs:
      test-passed: ${{ steps.test.outputs.passed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip packages
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-mock pytest-xdist

      - name: Run tests
        id: test
        run: |
          echo "Running ${{ matrix.test-suite }} tests..."
          
          if [[ "${{ matrix.test-suite }}" == "unit" ]]; then
            # Run unit tests with coverage and parallel execution
            pytest tests/ -m "not integration" --cov=src --cov-report=xml --cov-report=term -n auto || true
          else
            # Run integration tests with parallel execution
            pytest tests/ -m "integration" -n 2 || true
          fi
          
          echo "passed=true" >> $GITHUB_OUTPUT

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: test-results-${{ matrix.test-suite }}
          path: |
            pytest-results-*.xml
            coverage.xml
          retention-days: 7

  # 3. Docker 빌드 및 Push
  build-and-push:
    runs-on: self-hosted
    needs: [quality-check, test]
    if: |
      always() &&
      needs.quality-check.outputs.quality-passed == 'true' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    outputs:
      image-tag: ${{ steps.meta.outputs.version }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Login to Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME || 'admin' }}
          password: ${{ secrets.REGISTRY_PASSWORD || 'bingogo1' }}

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          driver-opts: network=host
          buildkitd-flags: --debug
          config-inline: |
            [registry."registry.jclee.me"]
              http = true
              insecure = true
          # 빌드 캐시 최적화
          install: true
          version: latest
          driver: docker-container

      - name: Generate metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value={{date 'YYYYMMDD-HHmmss' tz='Asia/Seoul'}}
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push
        id: build
        uses: docker/build-push-action@v4
        with:
          context: .
          file: deployment/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            GIT_COMMIT=${{ github.sha }}
            VERSION=${{ steps.meta.outputs.version }}

  # 4. Helm Chart 관리
  helm-chart:
    runs-on: self-hosted
    needs: build-and-push
    if: |
      needs.build-and-push.result == 'success' &&
      github.ref == 'refs/heads/main'
    outputs:
      chart-version: ${{ steps.package.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Helm
        run: |
          if ! command -v helm &> /dev/null; then
            curl https://get.helm.sh/helm-${{ env.HELM_VERSION }}-linux-amd64.tar.gz | tar xz
            sudo mv linux-amd64/helm /usr/local/bin/
          fi
          
          # Install helm-push plugin if not exists
          helm plugin list | grep cm-push || helm plugin install https://github.com/chartmuseum/helm-push

      - name: Update Helm dependencies
        run: |
          cd charts/blacklist
          helm dependency update

      - name: Package Helm Chart
        id: package
        run: |
          cd charts/blacklist
          
          # Generate semantic version
          CHART_VERSION="1.0.$(date +%Y%m%d%H%M%S)"
          echo "version=$CHART_VERSION" >> $GITHUB_OUTPUT
          
          # Update Chart.yaml
          sed -i "s/^version:.*/version: $CHART_VERSION/" Chart.yaml
          sed -i "s/^appVersion:.*/appVersion: \"${{ needs.build-and-push.outputs.image-tag }}\"/" Chart.yaml
          
          # Package chart
          helm package .

      - name: Push to ChartMuseum
        run: |
          # Configure ChartMuseum repo (if URL is configured)
          if [[ "${{ env.CHARTMUSEUM_URL }}" != "https://charts.jclee.me" ]]; then
            helm repo add chartmuseum ${{ env.CHARTMUSEUM_URL }} \
              --username ${{ secrets.CHARTMUSEUM_USERNAME || 'admin' }} \
              --password ${{ secrets.CHARTMUSEUM_PASSWORD || 'admin' }} \
              --insecure-skip-tls-verify \
              --force-update
            
            # Push chart from charts/blacklist directory
            cd charts/blacklist
            helm cm-push . chartmuseum --insecure
          else
            echo "⚠️ ChartMuseum URL not configured, skipping chart push"
          fi
          
          echo "📦 Helm Chart pushed successfully!"
          echo "Chart Version: ${{ steps.package.outputs.version }}"
          echo "App Version: ${{ needs.build-and-push.outputs.image-tag }}"

  # 5. 오프라인 패키지 생성 (스토리지 할당량으로 인해 임시 비활성화)
  offline-package:
    runs-on: self-hosted
    needs: [build-and-push, helm-chart]
    if: |
      false &&
      needs.build-and-push.result == 'success' &&
      needs.helm-chart.result == 'success' &&
      github.ref == 'refs/heads/main'
    outputs:
      package-name: ${{ steps.package.outputs.filename }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Create offline package
        id: package
        run: |
          # 패키지 이름 생성
          PACKAGE_NAME="blacklist-offline-$(date +%Y%m%d-%H%M%S)"
          PACKAGE_DIR="offline-packages/$PACKAGE_NAME"
          
          echo "🗂️ 오프라인 패키지 생성 중..."
          mkdir -p "$PACKAGE_DIR"
          
          # 1. 소스 코드 복사
          echo "📁 소스 코드 복사..."
          cp -r src/ "$PACKAGE_DIR/"
          cp -r deployment/ "$PACKAGE_DIR/"
          cp -r k8s/ "$PACKAGE_DIR/"
          cp -r charts/ "$PACKAGE_DIR/"
          cp -r scripts/ "$PACKAGE_DIR/"
          cp requirements.txt main.py init_database.py "$PACKAGE_DIR/"
          
          # 2. Docker 이미지 저장
          echo "🐳 Docker 이미지 저장..."
          docker save ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-push.outputs.image-tag }} \
            | gzip > "$PACKAGE_DIR/blacklist-image.tar.gz"
          
          # 3. Helm 차트 복사
          echo "📦 Helm 차트 복사..."
          cp charts/blacklist/blacklist-*.tgz "$PACKAGE_DIR/" || true
          
          # 4. 설치 가이드 생성
          echo "📋 설치 가이드 생성..."
          cat > "$PACKAGE_DIR/OFFLINE_INSTALL.md" << 'EOF'
          # 오프라인 설치 가이드
          
          ## 1. Docker 이미지 로드
          ```bash
          docker load < blacklist-image.tar.gz
          ```
          
          ## 2. Kubernetes 배포
          ```bash
          # 네임스페이스 생성
          kubectl create namespace blacklist
          
          # Kustomize로 배포
          kubectl apply -k k8s/
          ```
          
          ## 3. Helm 차트 설치 (선택사항)
          ```bash
          helm install blacklist blacklist-*.tgz -n blacklist
          ```
          
          ## 4. 로컬 실행
          ```bash
          # 의존성 설치
          pip install -r requirements.txt
          
          # 데이터베이스 초기화
          python3 init_database.py
          
          # 애플리케이션 실행
          python3 main.py
          ```
          EOF
          
          # 5. 패키지 압축
          echo "🗜️ 패키지 압축 중..."
          cd offline-packages
          tar -czf "$PACKAGE_NAME.tar.gz" "$PACKAGE_NAME/"
          
          # 6. 메타데이터 생성
          cat > "$PACKAGE_NAME.json" << EOF
          {
            "package_name": "$PACKAGE_NAME",
            "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "version": "${{ needs.build-and-push.outputs.image-tag }}",
            "git_commit": "${{ github.sha }}",
            "git_branch": "${{ github.ref_name }}",
            "docker_image": "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-push.outputs.image-tag }}",
            "helm_chart": "blacklist-${{ needs.helm-chart.outputs.chart-version }}.tgz",
            "size_mb": $(du -m "$PACKAGE_NAME.tar.gz" | cut -f1)
          }
          EOF
          
          echo "filename=$PACKAGE_NAME.tar.gz" >> $GITHUB_OUTPUT
          echo "✅ 오프라인 패키지 생성 완료: $PACKAGE_NAME.tar.gz"

      - name: Upload offline package artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.package.outputs.filename }}
          path: offline-packages/${{ steps.package.outputs.filename }}
          retention-days: 30

  # 6. ArgoCD 자동 동기화 및 배포 알림
  deploy-notify:
    runs-on: self-hosted
    needs: [build-and-push, helm-chart, offline-package]
    if: |
      always() &&
      needs.build-and-push.result == 'success'
    steps:
      - name: ArgoCD 자동 동기화 트리거
        if: github.ref == 'refs/heads/main'
        continue-on-error: true
        run: |
          echo "🔄 ArgoCD 동기화 트리거..."
          
          # ArgoCD CLI 설치 확인
          if ! command -v argocd &> /dev/null; then
            echo "⚠️ ArgoCD CLI not installed, using API instead"
            
            # ArgoCD API를 통한 동기화 (옵션)
            if [[ -n "${{ secrets.ARGOCD_TOKEN }}" ]]; then
              curl -k -X POST \
                -H "Authorization: Bearer ${{ secrets.ARGOCD_TOKEN }}" \
                -H "Content-Type: application/json" \
                -d '{"prune": true, "dryRun": false}' \
                "https://argo.jclee.me/api/v1/applications/blacklist/sync" || echo "⚠️ ArgoCD API sync failed"
            fi
          else
            # ArgoCD CLI로 동기화
            if [[ -n "${{ secrets.ARGOCD_TOKEN }}" ]]; then
              export ARGOCD_AUTH_TOKEN="${{ secrets.ARGOCD_TOKEN }}"
              argocd app sync blacklist --grpc-web --server argo.jclee.me || echo "⚠️ ArgoCD CLI sync failed"
              argocd app wait blacklist --health --grpc-web --server argo.jclee.me --timeout 300 || echo "⚠️ ArgoCD health check timeout"
            fi
          fi
          
          echo "✅ ArgoCD 동기화 요청 완료"
      
      - name: 배포 정보 출력
        run: |
          echo "🚀 GitOps 배포 준비 완료"
          echo "=========================="
          echo ""
          echo "📦 Docker Image"
          echo "  Registry: ${{ env.REGISTRY }}"
          echo "  Image: ${{ env.IMAGE_NAME }}:${{ needs.build-and-push.outputs.image-tag }}"
          echo "  Digest: ${{ needs.build-and-push.outputs.image-digest }}"
          echo ""
          echo "📊 Helm Chart"
          echo "  Repository: ${{ env.CHARTMUSEUM_URL }}"
          echo "  Version: ${{ needs.helm-chart.outputs.chart-version || 'N/A' }}"
          echo ""
          echo "📦 Offline Package"
          echo "  Package: ${{ needs.offline-package.outputs.package-name || 'N/A' }}"
          echo "  Available for download in GitHub Actions Artifacts"
          echo ""
          echo "🔗 Links"
          echo "  ArgoCD: https://argo.jclee.me"
          echo "  Service: https://blacklist.jclee.me"
          echo "  Health: https://blacklist.jclee.me/health"
          echo ""
          echo "📝 Commit"
          echo "  SHA: ${{ github.sha }}"
          echo "  Author: ${{ github.actor }}"
          echo "  Message: ${{ github.event.head_commit.message }}"
          echo ""
          echo "ArgoCD가 자동으로 새 이미지를 감지하고 배포합니다."

      - name: Cleanup old images
        if: github.ref == 'refs/heads/main'
        continue-on-error: true
        run: |
          # Docker 이미지 정리 (optional)
          docker image prune -af --filter "until=168h" || true
          
          # Buildx 캐시 정리 (optional)
          docker buildx prune --keep-storage 10GB -f || true

  # 7. 실패 시 알림 (optional)
  notify-failure:
    runs-on: self-hosted
    needs: [quality-check, test, build-and-push, helm-chart, offline-package]
    if: |
      always() &&
      (needs.quality-check.result == 'failure' ||
       needs.test.result == 'failure' ||
       needs.build-and-push.result == 'failure' ||
       needs.helm-chart.result == 'failure' ||
       needs.offline-package.result == 'failure')
    steps:
      - name: 실패 알림
        run: |
          echo "❌ 파이프라인 실패"
          echo "=================="
          echo ""
          echo "실패한 단계:"
          [[ "${{ needs.quality-check.result }}" == "failure" ]] && echo "  - Quality Check"
          [[ "${{ needs.test.result }}" == "failure" ]] && echo "  - Test"
          [[ "${{ needs.build-and-push.result }}" == "failure" ]] && echo "  - Build & Push"
          [[ "${{ needs.helm-chart.result }}" == "failure" ]] && echo "  - Helm Chart"
          [[ "${{ needs.offline-package.result }}" == "failure" ]] && echo "  - Offline Package"
          echo ""
          echo "GitHub Actions: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"