name: GitOps Pipeline

on:
  push:
    branches: [ main, develop ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '*.txt'
      - 'LICENSE'
      - '.gitignore'
  pull_request:
    branches: [ main ]
  workflow_dispatch:

# 동시 실행 제어
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ${{ secrets.REGISTRY_URL || 'registry.jclee.me' }}
  IMAGE_NAME: blacklist
  PYTHON_VERSION: '3.11'
  HELM_VERSION: 'v3.12.0'
  CHARTMUSEUM_URL: ${{ secrets.CHARTMUSEUM_URL || 'https://charts.jclee.me' }}

jobs:
  # 1. 코드 품질 검사
  quality-check:
    runs-on: self-hosted
    outputs:
      quality-passed: ${{ steps.quality.outputs.passed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip packages
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install flake8 black isort bandit safety semgrep

      - name: Code quality checks
        id: quality
        run: |
          echo "Running code quality checks..."
          
          # Linting
          flake8 src/ --max-line-length=88 --extend-ignore=E203,W503,W293,W291,E501,E302 --exit-zero
          
          # Code formatting
          black --check src/ --diff || echo "⚠️ Black formatting issues found (non-blocking)"
          
          # Import sorting
          isort src/ --check-only --diff || echo "⚠️ Import sorting issues found (non-blocking)"
          
          # Security scan
          bandit -r src/ -ll || echo "⚠️ Security issues found (non-blocking)"
          
          # Dependency check
          safety check || echo "⚠️ Dependency vulnerabilities found (non-blocking)"
          
          # Semgrep scan (optional)
          # semgrep --config=auto src/ || echo "⚠️ Semgrep issues found (non-blocking)"
          
          echo "passed=true" >> $GITHUB_OUTPUT

  # 2. 테스트
  test:
    runs-on: self-hosted
    needs: quality-check
    if: needs.quality-check.outputs.quality-passed == 'true'
    outputs:
      test-passed: ${{ steps.test.outputs.passed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Cache pip packages
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-mock

      - name: Run tests
        id: test
        run: |
          echo "Running tests..."
          
          # Run unit tests with coverage
          pytest tests/ -m "not integration" --cov=src --cov-report=xml --cov-report=term || true
          
          # Integration tests (optional)
          # pytest tests/ -m "integration" || echo "⚠️ Integration tests failed (non-blocking)"
          
          echo "passed=true" >> $GITHUB_OUTPUT

  # 3. Docker 빌드 및 Push
  build-and-push:
    runs-on: self-hosted
    needs: [quality-check, test]
    if: |
      needs.quality-check.outputs.quality-passed == 'true' &&
      needs.test.outputs.test-passed == 'true' &&
      (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    outputs:
      image-tag: ${{ steps.meta.outputs.version }}
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Login to Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME || 'admin' }}
          password: ${{ secrets.REGISTRY_PASSWORD || 'bingogo1' }}

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          driver-opts: network=host
          buildkitd-flags: --debug
          config-inline: |
            [registry."registry.jclee.me"]
              http = true
              insecure = true

      - name: Generate metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value={{date 'YYYYMMDD-HHmmss' tz='Asia/Seoul'}}
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}

      - name: Build and push
        id: build
        uses: docker/build-push-action@v4
        with:
          context: .
          file: deployment/Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            GIT_COMMIT=${{ github.sha }}
            VERSION=${{ steps.meta.outputs.version }}

  # 4. Helm Chart 관리
  helm-chart:
    runs-on: self-hosted
    needs: build-and-push
    if: |
      needs.build-and-push.result == 'success' &&
      github.ref == 'refs/heads/main'
    outputs:
      chart-version: ${{ steps.package.outputs.version }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Helm
        run: |
          if ! command -v helm &> /dev/null; then
            curl https://get.helm.sh/helm-${{ env.HELM_VERSION }}-linux-amd64.tar.gz | tar xz
            sudo mv linux-amd64/helm /usr/local/bin/
          fi
          
          # Install helm-push plugin if not exists
          helm plugin list | grep cm-push || helm plugin install https://github.com/chartmuseum/helm-push

      - name: Update Helm dependencies
        run: |
          cd charts/blacklist
          helm dependency update

      - name: Package Helm Chart
        id: package
        run: |
          cd charts/blacklist
          
          # Generate semantic version
          CHART_VERSION="1.0.$(date +%Y%m%d%H%M%S)"
          echo "version=$CHART_VERSION" >> $GITHUB_OUTPUT
          
          # Update Chart.yaml
          sed -i "s/^version:.*/version: $CHART_VERSION/" Chart.yaml
          sed -i "s/^appVersion:.*/appVersion: \"${{ needs.build-and-push.outputs.image-tag }}\"/" Chart.yaml
          
          # Package chart
          helm package .

      - name: Push to ChartMuseum
        run: |
          # Configure ChartMuseum repo (if URL is configured)
          if [[ "${{ env.CHARTMUSEUM_URL }}" != "https://charts.jclee.me" ]]; then
            helm repo add chartmuseum ${{ env.CHARTMUSEUM_URL }} \
              --username ${{ secrets.CHARTMUSEUM_USERNAME || 'admin' }} \
              --password ${{ secrets.CHARTMUSEUM_PASSWORD || 'admin' }} \
              --insecure-skip-tls-verify \
              --force-update
            
            # Push chart from charts/blacklist directory
            cd charts/blacklist
            helm cm-push . chartmuseum --insecure
          else
            echo "⚠️ ChartMuseum URL not configured, skipping chart push"
          fi
          
          echo "📦 Helm Chart pushed successfully!"
          echo "Chart Version: ${{ steps.package.outputs.version }}"
          echo "App Version: ${{ needs.build-and-push.outputs.image-tag }}"

  # 5. 오프라인 패키지 생성
  offline-package:
    runs-on: self-hosted
    needs: [build-and-push, helm-chart]
    if: |
      needs.build-and-push.result == 'success' &&
      needs.helm-chart.result == 'success' &&
      github.ref == 'refs/heads/main'
    outputs:
      package-name: ${{ steps.package.outputs.filename }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Create offline package
        id: package
        run: |
          # 패키지 이름 생성
          PACKAGE_NAME="blacklist-offline-$(date +%Y%m%d-%H%M%S)"
          PACKAGE_DIR="offline-packages/$PACKAGE_NAME"
          
          echo "🗂️ 오프라인 패키지 생성 중..."
          mkdir -p "$PACKAGE_DIR"
          
          # 1. 소스 코드 복사
          echo "📁 소스 코드 복사..."
          cp -r src/ "$PACKAGE_DIR/"
          cp -r deployment/ "$PACKAGE_DIR/"
          cp -r k8s/ "$PACKAGE_DIR/"
          cp -r charts/ "$PACKAGE_DIR/"
          cp -r scripts/ "$PACKAGE_DIR/"
          cp requirements.txt main.py init_database.py "$PACKAGE_DIR/"
          
          # 2. Docker 이미지 저장
          echo "🐳 Docker 이미지 저장..."
          docker save ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-push.outputs.image-tag }} \
            | gzip > "$PACKAGE_DIR/blacklist-image.tar.gz"
          
          # 3. Helm 차트 복사
          echo "📦 Helm 차트 복사..."
          cp charts/blacklist/blacklist-*.tgz "$PACKAGE_DIR/" || true
          
          # 4. 설치 가이드 생성
          echo "📋 설치 가이드 생성..."
          cat > "$PACKAGE_DIR/OFFLINE_INSTALL.md" << 'EOF'
          # 오프라인 설치 가이드
          
          ## 1. Docker 이미지 로드
          ```bash
          docker load < blacklist-image.tar.gz
          ```
          
          ## 2. Kubernetes 배포
          ```bash
          # 네임스페이스 생성
          kubectl create namespace blacklist
          
          # Kustomize로 배포
          kubectl apply -k k8s/
          ```
          
          ## 3. Helm 차트 설치 (선택사항)
          ```bash
          helm install blacklist blacklist-*.tgz -n blacklist
          ```
          
          ## 4. 로컬 실행
          ```bash
          # 의존성 설치
          pip install -r requirements.txt
          
          # 데이터베이스 초기화
          python3 init_database.py
          
          # 애플리케이션 실행
          python3 main.py
          ```
          EOF
          
          # 5. 패키지 압축
          echo "🗜️ 패키지 압축 중..."
          cd offline-packages
          tar -czf "$PACKAGE_NAME.tar.gz" "$PACKAGE_NAME/"
          
          # 6. 메타데이터 생성
          cat > "$PACKAGE_NAME.json" << EOF
          {
            "package_name": "$PACKAGE_NAME",
            "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "version": "${{ needs.build-and-push.outputs.image-tag }}",
            "git_commit": "${{ github.sha }}",
            "git_branch": "${{ github.ref_name }}",
            "docker_image": "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-push.outputs.image-tag }}",
            "helm_chart": "blacklist-${{ needs.helm-chart.outputs.chart-version }}.tgz",
            "size_mb": $(du -m "$PACKAGE_NAME.tar.gz" | cut -f1)
          }
          EOF
          
          echo "filename=$PACKAGE_NAME.tar.gz" >> $GITHUB_OUTPUT
          echo "✅ 오프라인 패키지 생성 완료: $PACKAGE_NAME.tar.gz"

      - name: Upload offline package artifact
        uses: actions/upload-artifact@v3
        with:
          name: ${{ steps.package.outputs.filename }}
          path: offline-packages/${{ steps.package.outputs.filename }}
          retention-days: 30

  # 6. 배포 알림 및 정리
  deploy-notify:
    runs-on: self-hosted
    needs: [build-and-push, helm-chart, offline-package]
    if: |
      always() &&
      needs.build-and-push.result == 'success'
    steps:
      - name: 배포 정보 출력
        run: |
          echo "🚀 GitOps 배포 준비 완료"
          echo "=========================="
          echo ""
          echo "📦 Docker Image"
          echo "  Registry: ${{ env.REGISTRY }}"
          echo "  Image: ${{ env.IMAGE_NAME }}:${{ needs.build-and-push.outputs.image-tag }}"
          echo "  Digest: ${{ needs.build-and-push.outputs.image-digest }}"
          echo ""
          echo "📊 Helm Chart"
          echo "  Repository: ${{ env.CHARTMUSEUM_URL }}"
          echo "  Version: ${{ needs.helm-chart.outputs.chart-version || 'N/A' }}"
          echo ""
          echo "📦 Offline Package"
          echo "  Package: ${{ needs.offline-package.outputs.package-name || 'N/A' }}"
          echo "  Available for download in GitHub Actions Artifacts"
          echo ""
          echo "🔗 Links"
          echo "  ArgoCD: Configure based on your environment"
          echo "  Service: Configure based on your domain"
          echo "  Health: Configure based on your domain"
          echo ""
          echo "📝 Commit"
          echo "  SHA: ${{ github.sha }}"
          echo "  Author: ${{ github.actor }}"
          echo "  Message: ${{ github.event.head_commit.message }}"
          echo ""
          echo "ArgoCD가 자동으로 새 이미지를 감지하고 배포합니다."

      - name: Cleanup old images
        if: github.ref == 'refs/heads/main'
        continue-on-error: true
        run: |
          # Docker 이미지 정리 (optional)
          docker image prune -af --filter "until=168h" || true
          
          # Buildx 캐시 정리 (optional)
          docker buildx prune --keep-storage 10GB -f || true

  # 7. 실패 시 알림 (optional)
  notify-failure:
    runs-on: self-hosted
    needs: [quality-check, test, build-and-push, helm-chart, offline-package]
    if: |
      always() &&
      (needs.quality-check.result == 'failure' ||
       needs.test.result == 'failure' ||
       needs.build-and-push.result == 'failure' ||
       needs.helm-chart.result == 'failure' ||
       needs.offline-package.result == 'failure')
    steps:
      - name: 실패 알림
        run: |
          echo "❌ 파이프라인 실패"
          echo "=================="
          echo ""
          echo "실패한 단계:"
          [[ "${{ needs.quality-check.result }}" == "failure" ]] && echo "  - Quality Check"
          [[ "${{ needs.test.result }}" == "failure" ]] && echo "  - Test"
          [[ "${{ needs.build-and-push.result }}" == "failure" ]] && echo "  - Build & Push"
          [[ "${{ needs.helm-chart.result }}" == "failure" ]] && echo "  - Helm Chart"
          [[ "${{ needs.offline-package.result }}" == "failure" ]] && echo "  - Offline Package"
          echo ""
          echo "GitHub Actions: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"