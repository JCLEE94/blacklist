name: GitOps CI/CD Pipeline

on:
  push:
    branches: [main, develop]
    tags: ['v*']
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests for emergency deployment'
        required: false
        default: false
        type: boolean

env:
  # Registry Configuration
  REGISTRY: ${{ secrets.REGISTRY_URL || 'registry.jclee.me' }}
  IMAGE_NAME: blacklist
  
  # Kubernetes Configuration
  NAMESPACE: blacklist
  
  # ArgoCD Configuration
  ARGOCD_SERVER: ${{ secrets.ARGOCD_SERVER || 'argo.jclee.me' }}
  ARGOCD_APP_NAME: blacklist
  
  # Chart Configuration
  CHARTMUSEUM_URL: ${{ secrets.CHARTMUSEUM_URL || 'https://charts.jclee.me' }}

jobs:
  # Quality Checks (Parallel)
  quality-check:
    runs-on: self-hosted
    strategy:
      matrix:
        check: [lint, security]
      fail-fast: false
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install Dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Run ${{ matrix.check }}
        run: |
          if [ "${{ matrix.check }}" == "lint" ]; then
            echo "ðŸ” Running linting checks..."
            flake8 src/ --max-line-length=88 --extend-ignore=E203,W503 || true
            black --check src/ --diff || true
            isort src/ --check-only --diff || true
          elif [ "${{ matrix.check }}" == "security" ]; then
            echo "ðŸ”’ Running security checks..."
            bandit -r src/ -f json -o bandit-report.json -ll || true
            safety check --json --output safety-report.json || true
          fi

  # Tests (Parallel)
  test:
    runs-on: self-hosted
    strategy:
      matrix:
        test-type: [unit, integration]
      fail-fast: false
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'

      - name: Install Dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Initialize Database
        if: matrix.test-type == 'integration'
        run: |
          python3 init_database.py

      - name: Run ${{ matrix.test-type }} tests
        run: |
          if [ "${{ matrix.test-type }}" == "unit" ]; then
            echo "ðŸ§ª Running unit tests..."
            pytest tests/unit/ -v --tb=short || true
          elif [ "${{ matrix.test-type }}" == "integration" ]; then
            echo "ðŸ§ª Running integration tests..."
            python3 test_integration.py || true
            pytest tests/integration/ -v --tb=short || true
          fi

  # Build and Push
  build-and-push:
    needs: [quality-check, test]
    if: always() && (needs.quality-check.result == 'success' || needs.quality-check.result == 'failure') && (needs.test.result == 'success' || needs.test.result == 'failure')
    runs-on: self-hosted
    outputs:
      image-tag: ${{ steps.meta.outputs.version }}
      chart-version: ${{ steps.chart.outputs.version }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          buildkitd-flags: --debug
          config-inline: |
            [registry."${{ env.REGISTRY }}"]
              http = true
              insecure = true

      - name: Login to Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME || 'admin' }}
          password: ${{ secrets.REGISTRY_PASSWORD || 'admin' }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v4
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value={{date 'YYYYMMDD-HHmmss'}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: deployment/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
          build-args: |
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            BUILD_VERSION=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.version'] }}

      - name: Prepare Chart Version
        id: chart
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            CHART_VERSION="${{ github.ref_name }}"
            CHART_VERSION=${CHART_VERSION#v}
          else
            CHART_VERSION="0.1.0-${{ github.run_number }}"
          fi
          echo "version=${CHART_VERSION}" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Chart Version: ${CHART_VERSION}"

      - name: Update and Package Helm Chart
        run: |
          # Install Helm if not available
          if ! command -v helm &> /dev/null; then
            curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          fi
          
          # Update Chart.yaml
          sed -i "s/^version:.*/version: ${{ steps.chart.outputs.version }}/" ./charts/blacklist/Chart.yaml
          sed -i "s/^appVersion:.*/appVersion: \"${{ steps.meta.outputs.version }}\"/" ./charts/blacklist/Chart.yaml
          
          # Update values with new image tag
          cat > ./charts/blacklist/values-override.yaml << EOF
          image:
            repository: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
            tag: "${{ steps.meta.outputs.version }}"
            pullPolicy: Always
          EOF
          
          # Package chart
          helm package ./charts/blacklist

      - name: Push to ChartMuseum
        if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')
        run: |
          CHART_FILE="blacklist-${{ steps.chart.outputs.version }}.tgz"
          
          # Upload to ChartMuseum
          curl -u ${{ secrets.CHARTMUSEUM_USERNAME || 'admin' }}:${{ secrets.CHARTMUSEUM_PASSWORD || 'admin' }} \
            --data-binary "@${CHART_FILE}" \
            --fail \
            "${{ env.CHARTMUSEUM_URL }}/api/charts" || {
              echo "âŒ Chart upload failed"
              exit 1
            }
          
          echo "âœ… Chart uploaded successfully: ${{ steps.chart.outputs.version }}"

  # ArgoCD Deployment
  deploy:
    needs: build-and-push
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')
    runs-on: self-hosted
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Create ArgoCD Application
        env:
          ARGOCD_AUTH_TOKEN: ${{ secrets.ARGOCD_AUTH_TOKEN }}
        run: |
          # Install ArgoCD CLI if not available
          if ! command -v argocd &> /dev/null; then
            curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
            chmod +x /usr/local/bin/argocd
          fi
          
          # Create Application manifest
          cat > argocd-app.yaml << EOF
          apiVersion: argoproj.io/v1alpha1
          kind: Application
          metadata:
            name: ${{ env.ARGOCD_APP_NAME }}
            namespace: argocd
            finalizers:
              - resources-finalizer.argocd.argoproj.io
          spec:
            project: default
            source:
              repoURL: ${{ env.CHARTMUSEUM_URL }}
              chart: blacklist
              targetRevision: ${{ needs.build-and-push.outputs.chart-version }}
              helm:
                valueFiles:
                  - values-override.yaml
            destination:
              server: https://kubernetes.default.svc
              namespace: ${{ env.NAMESPACE }}
            syncPolicy:
              automated:
                prune: true
                selfHeal: true
                allowEmpty: false
              syncOptions:
                - CreateNamespace=true
                - ApplyOutOfSyncOnly=true
              retry:
                limit: 5
                backoff:
                  duration: 5s
                  factor: 2
                  maxDuration: 3m
          EOF
          
          # Apply the application
          kubectl apply -f argocd-app.yaml || echo "Application already exists"
          
          # Trigger sync
          argocd app sync ${{ env.ARGOCD_APP_NAME }} --grpc-web --server ${{ env.ARGOCD_SERVER }} || true

      - name: Wait for Deployment
        run: |
          echo "â³ Waiting for deployment to complete..."
          sleep 30
          
          # Check deployment status
          kubectl rollout status deployment/${{ env.IMAGE_NAME }} -n ${{ env.NAMESPACE }} --timeout=300s || true

  # Post-deployment validation
  validate:
    needs: deploy
    runs-on: self-hosted
    steps:
      - name: Health Check
        run: |
          echo "ðŸ¥ Running health checks..."
          MAX_RETRIES=10
          RETRY_COUNT=0
          
          # Get service endpoint
          SERVICE_URL=$(kubectl get svc ${{ env.IMAGE_NAME }} -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "localhost:8541")
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -f http://${SERVICE_URL}/health; then
              echo "âœ… Application is healthy!"
              break
            else
              echo "â³ Waiting for application... (${RETRY_COUNT}/${MAX_RETRIES})"
              sleep 10
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
          done

      - name: Integration Test
        run: |
          echo "ðŸ§ª Running post-deployment tests..."
          
          # Simple API tests
          SERVICE_URL=$(kubectl get svc ${{ env.IMAGE_NAME }} -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "localhost:8541")
          
          # Test endpoints
          curl -s http://${SERVICE_URL}/api/stats | jq . || true
          curl -s http://${SERVICE_URL}/api/collection/status | jq . || true

      - name: Notify Success
        if: success()
        run: |
          echo "ðŸŽ‰ Deployment successful!"
          echo "ðŸ“Š Version: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "ðŸ“¦ Chart: ${{ needs.build-and-push.outputs.chart-version }}"
          echo "ðŸ”— Application: https://${{ env.ARGOCD_SERVER }}/applications/${{ env.ARGOCD_APP_NAME }}"

  # Generate Offline Package
  offline-package:
    needs: [build-and-push, validate]
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')
    runs-on: self-hosted
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Create Offline Package Directory
        run: |
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          PACKAGE_NAME="blacklist-offline-${TIMESTAMP}"
          PACKAGE_DIR="/tmp/${PACKAGE_NAME}"
          
          echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV
          echo "PACKAGE_DIR=${PACKAGE_DIR}" >> $GITHUB_ENV
          echo "TIMESTAMP=${TIMESTAMP}" >> $GITHUB_ENV
          
          mkdir -p "${PACKAGE_DIR}"/{source,docker,helm,scripts,docs}
          echo "ðŸ“¦ Created package directory: ${PACKAGE_DIR}"

      - name: Export Docker Image
        run: |
          IMAGE_TAG="${{ needs.build-and-push.outputs.image-tag }}"
          IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}"
          
          echo "ðŸ’¾ Exporting Docker image: ${IMAGE_NAME}"
          docker pull "${IMAGE_NAME}"
          docker save "${IMAGE_NAME}" | gzip > "${PACKAGE_DIR}/docker/blacklist-image.tar.gz"
          
          # Create image info file
          cat > "${PACKAGE_DIR}/docker/image-info.txt" << EOF
          Image: ${IMAGE_NAME}
          Tag: ${IMAGE_TAG}
          Registry: ${{ env.REGISTRY }}
          Build Date: $(date -u)
          Git Commit: ${{ github.sha }}
          Git Branch: ${{ github.ref_name }}
          EOF
          
          echo "âœ… Docker image exported successfully"

      - name: Package Source Code
        run: |
          echo "ðŸ“ Packaging source code..."
          
          # Create source archive excluding unnecessary files
          tar -czf "${PACKAGE_DIR}/source/blacklist-source.tar.gz" \
            --exclude='.git' \
            --exclude='node_modules' \
            --exclude='__pycache__' \
            --exclude='*.pyc' \
            --exclude='.pytest_cache' \
            --exclude='instance/*.db' \
            --exclude='data' \
            --exclude='logs' \
            .
          
          # Copy important configuration files
          cp -r k8s "${PACKAGE_DIR}/source/"
          cp -r charts "${PACKAGE_DIR}/source/"
          cp requirements.txt "${PACKAGE_DIR}/source/"
          cp .env.example "${PACKAGE_DIR}/source/"
          cp CLAUDE.md "${PACKAGE_DIR}/source/"
          
          echo "âœ… Source code packaged successfully"

      - name: Package Helm Charts
        run: |
          echo "ðŸ“Š Packaging Helm charts..."
          
          # Copy Helm chart
          cp -r charts/blacklist "${PACKAGE_DIR}/helm/"
          
          # Copy packaged chart if exists
          if [ -f "blacklist-${{ needs.build-and-push.outputs.chart-version }}.tgz" ]; then
            cp "blacklist-${{ needs.build-and-push.outputs.chart-version }}.tgz" "${PACKAGE_DIR}/helm/"
          fi
          
          # Create Helm values for offline deployment
          cat > "${PACKAGE_DIR}/helm/values-offline.yaml" << EOF
          image:
            repository: blacklist
            tag: "${{ needs.build-and-push.outputs.image-tag }}"
            pullPolicy: Never
          
          service:
            type: NodePort
            nodePort: 32452
          
          ingress:
            enabled: false
          
          resources:
            limits:
              cpu: 500m
              memory: 512Mi
            requests:
              cpu: 100m
              memory: 128Mi
          EOF
          
          echo "âœ… Helm charts packaged successfully"

      - name: Create Installation Scripts
        run: |
          echo "ðŸ”§ Creating installation scripts..."
          
          # Docker Compose installation script
          cat > "${PACKAGE_DIR}/scripts/install-docker-compose.sh" << 'EOF'
          #!/bin/bash
          # Blacklist Docker Compose ì„¤ì¹˜ ìŠ¤í¬ë¦½íŠ¸
          
          set -e
          
          echo "ðŸš€ Blacklist Docker Compose ì„¤ì¹˜ ì‹œìž‘..."
          
          # Load Docker image
          echo "ðŸ“¦ Docker ì´ë¯¸ì§€ ë¡œë”©..."
          docker load < ../docker/blacklist-image.tar.gz
          
          # Copy source files
          echo "ðŸ“‚ ì†ŒìŠ¤ íŒŒì¼ ë³µì‚¬..."
          tar -xzf ../source/blacklist-source.tar.gz -C .
          
          # Setup environment
          echo "âš™ï¸ í™˜ê²½ ì„¤ì •..."
          cp .env.example .env
          echo "Please edit .env file with your configuration"
          
          # Initialize database
          echo "ðŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”..."
          python3 init_database.py
          
          # Start services
          echo "ðŸŽ¯ ì„œë¹„ìŠ¤ ì‹œìž‘..."
          docker-compose -f deployment/docker-compose.yml up -d
          
          echo "âœ… ì„¤ì¹˜ ì™„ë£Œ!"
          echo "ðŸŒ ì ‘ì† URL: http://localhost:8541"
          EOF
          
          # Kubernetes installation script
          cat > "${PACKAGE_DIR}/scripts/install-kubernetes.sh" << 'EOF'
          #!/bin/bash
          # Blacklist Kubernetes ì„¤ì¹˜ ìŠ¤í¬ë¦½íŠ¸
          
          set -e
          
          echo "ðŸš€ Blacklist Kubernetes ì„¤ì¹˜ ì‹œìž‘..."
          
          # Load Docker image to all nodes
          echo "ðŸ“¦ Docker ì´ë¯¸ì§€ ëª¨ë“  ë…¸ë“œì— ë¡œë”©..."
          docker load < ../docker/blacklist-image.tar.gz
          
          # Apply Kubernetes manifests
          echo "ðŸŽ¯ Kubernetes ë§¤ë‹ˆíŽ˜ìŠ¤íŠ¸ ì ìš©..."
          kubectl create namespace blacklist --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -k ../source/k8s/
          
          # Wait for deployment
          echo "â³ ë°°í¬ ëŒ€ê¸° ì¤‘..."
          kubectl rollout status deployment/blacklist -n blacklist --timeout=300s
          
          echo "âœ… ì„¤ì¹˜ ì™„ë£Œ!"
          echo "ðŸŒ ì„œë¹„ìŠ¤ ì •ë³´:"
          kubectl get svc -n blacklist
          EOF
          
          # Helm installation script
          cat > "${PACKAGE_DIR}/scripts/install-helm.sh" << 'EOF'
          #!/bin/bash
          # Blacklist Helm ì„¤ì¹˜ ìŠ¤í¬ë¦½íŠ¸
          
          set -e
          
          echo "ðŸš€ Blacklist Helm ì„¤ì¹˜ ì‹œìž‘..."
          
          # Load Docker image
          echo "ðŸ“¦ Docker ì´ë¯¸ì§€ ë¡œë”©..."
          docker load < ../docker/blacklist-image.tar.gz
          
          # Install with Helm
          echo "âš™ï¸ Helm ì„¤ì¹˜..."
          helm upgrade --install blacklist ../helm/blacklist \
            -f ../helm/values-offline.yaml \
            --namespace blacklist \
            --create-namespace \
            --wait \
            --timeout 300s
          
          echo "âœ… ì„¤ì¹˜ ì™„ë£Œ!"
          echo "ðŸŒ ì„œë¹„ìŠ¤ ì •ë³´:"
          kubectl get svc -n blacklist
          EOF
          
          # Make scripts executable
          chmod +x "${PACKAGE_DIR}/scripts/"*.sh
          
          echo "âœ… ì„¤ì¹˜ ìŠ¤í¬ë¦½íŠ¸ ìƒì„± ì™„ë£Œ"

      - name: Create Documentation
        run: |
          echo "ðŸ“š ë¬¸ì„œ ìƒì„± ì¤‘..."
          
          # Installation guide
          cat > "${PACKAGE_DIR}/docs/INSTALLATION.md" << EOF
          # Blacklist ì˜¤í”„ë¼ì¸ ì„¤ì¹˜ ê°€ì´ë“œ
          
          ## ðŸ“¦ íŒ¨í‚¤ì§€ ë‚´ìš©
          
          - \`source/\` - ì†ŒìŠ¤ ì½”ë“œ ë° ì„¤ì • íŒŒì¼
          - \`docker/\` - Docker ì´ë¯¸ì§€ ë° ì •ë³´
          - \`helm/\` - Helm ì°¨íŠ¸ ë° ì„¤ì •
          - \`scripts/\` - ì„¤ì¹˜ ìŠ¤í¬ë¦½íŠ¸
          - \`docs/\` - ë¬¸ì„œ
          
          ## ðŸš€ ì„¤ì¹˜ ë°©ë²•
          
          ### 1. Docker Compose ì„¤ì¹˜
          \`\`\`bash
          cd scripts
          ./install-docker-compose.sh
          \`\`\`
          
          ### 2. Kubernetes ì„¤ì¹˜
          \`\`\`bash
          cd scripts
          ./install-kubernetes.sh
          \`\`\`
          
          ### 3. Helm ì„¤ì¹˜ (ê¶Œìž¥)
          \`\`\`bash
          cd scripts
          ./install-helm.sh
          \`\`\`
          
          ## âš™ï¸ ì„¤ì •
          
          ### í™˜ê²½ ë³€ìˆ˜
          - REGTECH_USERNAME: REGTECH ì‚¬ìš©ìžëª…
          - REGTECH_PASSWORD: REGTECH ë¹„ë°€ë²ˆí˜¸
          - SECUDIUM_USERNAME: SECUDIUM ì‚¬ìš©ìžëª…
          - SECUDIUM_PASSWORD: SECUDIUM ë¹„ë°€ë²ˆí˜¸
          
          ### í¬íŠ¸ ì„¤ì •
          - ê°œë°œ: 8541
          - í”„ë¡œë•ì…˜: 2541
          - NodePort: 32452
          
          ## ðŸ”§ ë¬¸ì œ í•´ê²°
          
          ### Docker ì´ë¯¸ì§€ ë¡œë”© ì‹¤íŒ¨
          \`\`\`bash
          # ì´ë¯¸ì§€ ì••ì¶• í•´ì œ ë° ë¡œë”©
          gunzip -c docker/blacklist-image.tar.gz | docker load
          \`\`\`
          
          ### ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”
          \`\`\`bash
          python3 init_database.py --force
          \`\`\`
          
          ### ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸
          \`\`\`bash
          # Docker Compose
          docker-compose -f deployment/docker-compose.yml ps
          
          # Kubernetes
          kubectl get pods -n blacklist
          
          # Helm
          helm status blacklist -n blacklist
          \`\`\`
          
          ## ðŸ“Š ì‹œìŠ¤í…œ ìš”êµ¬ì‚¬í•­
          
          - Docker 20.10+
          - Kubernetes 1.20+ (ì„ íƒì‚¬í•­)
          - Helm 3.0+ (ì„ íƒì‚¬í•­)
          - Python 3.9+
          - ìµœì†Œ ë©”ëª¨ë¦¬: 512MB
          - ìµœì†Œ ì €ìž¥ê³µê°„: 2GB
          
          ## ðŸŒ ì ‘ì† ì •ë³´
          
          ì„¤ì¹˜ ì™„ë£Œ í›„ ë‹¤ìŒ URLë¡œ ì ‘ì†:
          - Docker Compose: http://localhost:8541
          - Kubernetes NodePort: http://\<node-ip\>:32452
          - Kubernetes Ingress: https://blacklist.yourdomain.com
          EOF
          
          # Copy project documentation
          cp README.md "${PACKAGE_DIR}/docs/" 2>/dev/null || echo "README.md not found"
          cp CHANGELOG.md "${PACKAGE_DIR}/docs/" 2>/dev/null || echo "CHANGELOG.md not found"
          cp docs/*.md "${PACKAGE_DIR}/docs/" 2>/dev/null || echo "No additional docs found"
          
          echo "âœ… ë¬¸ì„œ ìƒì„± ì™„ë£Œ"

      - name: Create Package Metadata
        run: |
          echo "ðŸ“‹ íŒ¨í‚¤ì§€ ë©”íƒ€ë°ì´í„° ìƒì„±..."
          
          cat > "${PACKAGE_DIR}/package-info.json" << EOF
          {
            "name": "blacklist-offline-package",
            "version": "${{ needs.build-and-push.outputs.image-tag }}",
            "chart_version": "${{ needs.build-and-push.outputs.chart-version }}",
            "build_date": "$(date -u -Iseconds)",
            "git_commit": "${{ github.sha }}",
            "git_branch": "${{ github.ref_name }}",
            "git_tag": "${{ github.ref_type == 'tag' && github.ref_name || 'none' }}",
            "registry": "${{ env.REGISTRY }}",
            "image": "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-push.outputs.image-tag }}",
            "components": {
              "source_code": "source/blacklist-source.tar.gz",
              "docker_image": "docker/blacklist-image.tar.gz",
              "helm_chart": "helm/blacklist/",
              "installation_scripts": "scripts/",
              "documentation": "docs/"
            },
            "installation_methods": [
              "docker-compose",
              "kubernetes",
              "helm"
            ],
            "system_requirements": {
              "docker": "20.10+",
              "kubernetes": "1.20+ (optional)",
              "helm": "3.0+ (optional)",
              "python": "3.9+",
              "memory": "512MB minimum",
              "storage": "2GB minimum"
            }
          }
          EOF
          
          # Create checksums
          echo "ðŸ” ì²´í¬ì„¬ ìƒì„±..."
          cd "${PACKAGE_DIR}"
          find . -type f -exec sha256sum {} + > checksums.txt
          
          echo "âœ… íŒ¨í‚¤ì§€ ë©”íƒ€ë°ì´í„° ìƒì„± ì™„ë£Œ"

      - name: Create Final Archive
        run: |
          echo "ðŸ—œï¸ ìµœì¢… íŒ¨í‚¤ì§€ ì•„ì¹´ì´ë¸Œ ìƒì„±..."
          
          cd /tmp
          tar -czf "${PACKAGE_NAME}.tar.gz" "${PACKAGE_NAME}/"
          
          # Get package size
          PACKAGE_SIZE=$(du -h "${PACKAGE_NAME}.tar.gz" | cut -f1)
          echo "ðŸ“¦ íŒ¨í‚¤ì§€ í¬ê¸°: ${PACKAGE_SIZE}"
          
          # Move to workspace for artifact upload
          mv "${PACKAGE_NAME}.tar.gz" "${GITHUB_WORKSPACE}/"
          
          echo "PACKAGE_SIZE=${PACKAGE_SIZE}" >> $GITHUB_ENV
          echo "âœ… ì˜¤í”„ë¼ì¸ íŒ¨í‚¤ì§€ ìƒì„± ì™„ë£Œ: ${PACKAGE_NAME}.tar.gz"

      - name: Upload Offline Package
        uses: actions/upload-artifact@v3
        with:
          name: ${{ env.PACKAGE_NAME }}
          path: ${{ env.PACKAGE_NAME }}.tar.gz
          retention-days: 30

      - name: Create Release Asset (for tags)
        if: startsWith(github.ref, 'refs/tags/')
        run: |
          echo "ðŸ·ï¸ ë¦´ë¦¬ìŠ¤ ìžì‚°ìœ¼ë¡œ íŒ¨í‚¤ì§€ ì¶”ê°€..."
          
          # Install gh CLI if not available
          if ! command -v gh &> /dev/null; then
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo gpg --dearmor -o /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt update
            sudo apt install gh
          fi
          
          # Upload to release
          gh release upload ${{ github.ref_name }} "${PACKAGE_NAME}.tar.gz" \
            --clobber \
            --repo ${{ github.repository }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Package Summary
        run: |
          echo "ðŸ“Š ì˜¤í”„ë¼ì¸ íŒ¨í‚¤ì§€ ìƒì„± ì™„ë£Œ!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ðŸ“¦ íŒ¨í‚¤ì§€ëª…: ${{ env.PACKAGE_NAME }}.tar.gz"
          echo "ðŸ“ íŒ¨í‚¤ì§€ í¬ê¸°: ${{ env.PACKAGE_SIZE }}"
          echo "ðŸ·ï¸ ì´ë¯¸ì§€ íƒœê·¸: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "ðŸ“Š ì°¨íŠ¸ ë²„ì „: ${{ needs.build-and-push.outputs.chart-version }}"
          echo "ðŸ• ìƒì„± ì‹œê°„: ${{ env.TIMESTAMP }}"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ðŸ“¥ ë‹¤ìš´ë¡œë“œ ë°©ë²•:"
          echo "1. GitHub Actions Artifactsì—ì„œ ë‹¤ìš´ë¡œë“œ"
          echo "2. GitHub Releasesì—ì„œ ë‹¤ìš´ë¡œë“œ (íƒœê·¸ ë¹Œë“œì‹œ)"
          echo ""
          echo "ðŸš€ ì„¤ì¹˜ ë°©ë²•:"
          echo "1. tar -xzf ${{ env.PACKAGE_NAME }}.tar.gz"
          echo "2. cd ${{ env.PACKAGE_NAME }}"
          echo "3. cat docs/INSTALLATION.md"

  # Cleanup old images
  cleanup:
    needs: [validate, offline-package]
    runs-on: self-hosted
    if: always()
    steps:
      - name: Clean old images
        run: |
          echo "ðŸ§¹ Cleaning old images..."
          # Keep only last 10 images
          docker image prune -a --force --filter "until=72h" || true
          
      - name: Clean old packages
        run: |
          echo "ðŸ§¹ Cleaning old offline packages..."
          # Clean packages older than 7 days
          find /tmp -name "blacklist-offline-*" -type d -mtime +7 -exec rm -rf {} + 2>/dev/null || true