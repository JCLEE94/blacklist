name: Scheduled Data Collection

on:
  schedule:
    # ë§¤ì¼ ì˜¤ì „ 2ì‹œ (KST 11ì‹œ)ì— ì‹¤í–‰
    - cron: '0 17 * * *'
  workflow_dispatch:
    inputs:
      sources:
        description: 'Collection sources (comma-separated: regtech,secudium)'
        required: false
        default: 'regtech,secudium'

env:
  DEPLOY_HOST: registry.jclee.me
  DEPLOY_PORT: 1112

jobs:
  collect-data:
    runs-on: self-hosted
    
    steps:
      - name: Trigger collection on Kubernetes
        run: |
          echo "ğŸš€ Starting scheduled data collection..."
          
          # ìˆ˜ì§‘ ì†ŒìŠ¤ ê²°ì •
          SOURCES="${{ github.event.inputs.sources || 'regtech,secudium' }}"
          echo "ğŸ“Š Collection sources: $SOURCES"
          
          # NodePort ì„œë¹„ìŠ¤ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          NODE_PORT=$(kubectl get svc blacklist-nodeport -n blacklist -o jsonpath='{.spec.ports[0].nodePort}')
          BASE_URL="http://$NODE_IP:$NODE_PORT"
          
          echo "ğŸ”— API endpoint: $BASE_URL"
          
          # ìˆ˜ì§‘ í™œì„±í™” ìƒíƒœ í™•ì¸
          COLLECTION_STATUS=$(curl -s "$BASE_URL/api/collection/status" | grep -o '"enabled":[^,}]*' | cut -d':' -f2 | tr -d ' "')
          
          if [ "$COLLECTION_STATUS" != "true" ]; then
            echo "Collection is disabled. Enabling..."
            curl -X POST "$BASE_URL/api/collection/enable"
            sleep 5
          fi
          
          # ê° ì†ŒìŠ¤ì— ëŒ€í•´ ìˆ˜ì§‘ íŠ¸ë¦¬ê±°
          IFS=',' read -ra SOURCE_ARRAY <<< "$SOURCES"
          for source in "${SOURCE_ARRAY[@]}"; do
            source=$(echo $source | tr -d ' ')  # ê³µë°± ì œê±°
            echo "ğŸ”„ Triggering $source collection..."
            curl -X POST "$BASE_URL/api/collection/$source/trigger"
            
            # ìˆ˜ì§‘ ì™„ë£Œ ëŒ€ê¸° (ìµœëŒ€ 10ë¶„)
            COUNTER=0
            while [ $COUNTER -lt 60 ]; do
              STATUS=$(curl -s "$BASE_URL/api/collection/status" | grep -o "\"$source\":{[^}]*" | grep -o '"running":[^,}]*' | cut -d':' -f2 | tr -d ' "')
              if [ "$STATUS" != "true" ]; then
                echo "âœ… $source collection completed"
                break
              fi
              echo "â³ $source collection in progress... ($COUNTER/60)"
              sleep 10
              COUNTER=$((COUNTER+1))
            done
            
            if [ $COUNTER -eq 60 ]; then
              echo "âš ï¸ $source collection timed out"
            fi
          done
          
          # ìˆ˜ì§‘ ê²°ê³¼ í™•ì¸
          echo "ğŸ“Š Collection statistics:"
          curl -s "$BASE_URL/api/stats"

      - name: Check collection results
        run: |
          echo "ğŸ“‹ Checking collection results..."
          
          # NodePort ì„œë¹„ìŠ¤ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          NODE_PORT=$(kubectl get svc blacklist-nodeport -n blacklist -o jsonpath='{.spec.ports[0].nodePort}')
          BASE_URL="http://$NODE_IP:$NODE_PORT"
          
          # ìˆ˜ì§‘ ë¡œê·¸ í™•ì¸
          echo "=== Recent collection logs ==="
          kubectl logs deployment/blacklist -n blacklist --since=30m | grep -E "(Collection|REGTECH|SECUDIUM)" | tail -50
          
          # í†µê³„ ì •ë³´
          echo "=== Collection statistics ==="
          curl -s "$BASE_URL/api/v2/analytics/trends" || curl -s "$BASE_URL/api/stats"

      - name: Log collection status
        if: always()
        run: |
          echo "Scheduled collection ${{ job.status }}"
          echo "Sources: ${{ github.event.inputs.sources || 'regtech,secudium' }}"
          echo "Time: $(date)"

  backup-data:
    runs-on: self-hosted
    needs: collect-data
    if: success()
    
    steps:
      - name: Backup collected data from Kubernetes
        run: |
          echo "ğŸ’¾ Starting data backup..."
          
          # ë°±ì—… ë””ë ‰í† ë¦¬ ìƒì„±
          BACKUP_DIR="/tmp/blacklist_backup/$(date +%Y%m%d_%H%M%S)"
          mkdir -p $BACKUP_DIR
          
          # ì‹¤í–‰ ì¤‘ì¸ Pod ì„ íƒ
          POD_NAME=$(kubectl get pods -n blacklist -l app=blacklist -o jsonpath='{.items[0].metadata.name}')
          echo "ğŸ“¦ Using pod: $POD_NAME"
          
          # ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—…
          echo "ğŸ“Š Backing up database..."
          kubectl exec $POD_NAME -n blacklist -- sqlite3 /app/instance/blacklist.db ".backup /tmp/blacklist_backup.db"
          kubectl cp blacklist/$POD_NAME:/tmp/blacklist_backup.db $BACKUP_DIR/blacklist.db
          
          # ìˆ˜ì§‘ ë¡œê·¸ ë°±ì—…
          echo "ğŸ“ Backing up logs..."
          kubectl logs deployment/blacklist -n blacklist --since=24h > $BACKUP_DIR/collection_logs.txt
          
          # í†µê³„ ì •ë³´ ì €ì¥
          echo "ğŸ“ˆ Saving statistics..."
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
          NODE_PORT=$(kubectl get svc blacklist-nodeport -n blacklist -o jsonpath='{.spec.ports[0].nodePort}')
          curl -s "http://$NODE_IP:$NODE_PORT/api/stats" > $BACKUP_DIR/statistics.json
          
          # Pod ìƒíƒœ ì •ë³´ ì €ì¥
          kubectl get pods -n blacklist -o wide > $BACKUP_DIR/pod_status.txt
          kubectl describe deployment blacklist -n blacklist > $BACKUP_DIR/deployment_info.txt
          
          # ë°±ì—… ì••ì¶•
          tar -czf $BACKUP_DIR.tar.gz -C $(dirname $BACKUP_DIR) $(basename $BACKUP_DIR)
          
          # ì˜êµ¬ ì €ì¥ì†Œë¡œ ì´ë™ (ì„ íƒì‚¬í•­)
          if [ -d "/backup/blacklist" ]; then
            mv $BACKUP_DIR.tar.gz /backup/blacklist/
            echo "âœ… Backup saved to: /backup/blacklist/$(basename $BACKUP_DIR).tar.gz"
          else
            echo "âœ… Backup created: $BACKUP_DIR.tar.gz"
          fi
          
          # ì„ì‹œ ë””ë ‰í† ë¦¬ ì •ë¦¬
          rm -rf $BACKUP_DIR
          
          # ì˜¤ë˜ëœ ë°±ì—… ì •ë¦¬ (30ì¼ ì´ìƒ)
          if [ -d "/backup/blacklist" ]; then
            find /backup/blacklist -name "*.tar.gz" -mtime +30 -delete
            echo "ğŸ§¹ Old backups cleaned up"
          fi