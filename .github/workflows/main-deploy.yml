name: Auto Deploy to Registry

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: registry.jclee.me
  IMAGE_NAME: blacklist
  REDIS_IMAGE_NAME: blacklist-redis
  POSTGRESQL_IMAGE_NAME: blacklist-postgresql
  DOCKER_BUILDKIT: 1

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest  # GitHub hosted runner for reliability
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: network=host
      
    - name: Cache Docker layers
      uses: actions/cache@v3
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    - name: Login to Container Registry
      run: |
        echo "Logging into registry: ${{ env.REGISTRY }}"
        echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ${{ env.REGISTRY }} -u ${{ secrets.REGISTRY_USERNAME }} --password-stdin
        if [ $? -ne 0 ]; then
          echo "Failed to login to registry"
          exit 1
        fi

    - name: Build Docker images
      run: |
        echo "ğŸ³ Building Blacklist main image..."
        
        # Determine Dockerfile location
        if [ -f docker/Dockerfile ]; then
          DOCKERFILE_PATH="docker/Dockerfile"
        elif [ -f Dockerfile ]; then
          DOCKERFILE_PATH="Dockerfile"
        else
          echo "Creating default Dockerfile..."
          cat > Dockerfile << 'EOF'
        FROM python:3.11-slim
        WORKDIR /app
        COPY requirements.txt .
        RUN pip install --no-cache-dir -r requirements.txt
        COPY . .
        EXPOSE 2542
        CMD ["python", "app/main.py"]
        EOF
          DOCKERFILE_PATH="Dockerfile"
        fi
        
        docker buildx build \
          --platform linux/amd64 \
          --cache-from type=local,src=/tmp/.buildx-cache \
          --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
          -f "$DOCKERFILE_PATH" \
          -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
          -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          --load \
          .
        
        # Build support images only if configs exist
        if [ -d docker/redis ] && [ -f docker/redis/Dockerfile ]; then
          echo "ğŸ”´ Building custom Redis image..."
          DOCKER_BUILDKIT=0 docker build \
            -f docker/redis/Dockerfile \
            -t ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:latest \
            -t ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:${{ github.sha }} \
            docker/redis/
        else
          echo "â„¹ï¸ No custom Redis image configuration found"
        fi
        
        if [ -d docker/postgresql ] && [ -f docker/postgresql/Dockerfile ]; then
          echo "ğŸ˜ Building custom PostgreSQL image..."
          DOCKER_BUILDKIT=0 docker build \
            -f docker/postgresql/Dockerfile \
            -t ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:latest \
            -t ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:${{ github.sha }} \
            docker/postgresql/
        else
          echo "â„¹ï¸ No custom PostgreSQL image configuration found"
        fi

    - name: Push to registry
      run: |
        echo "ğŸš€ Pushing Blacklist main image..."
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        
        # Push support images only if they were built
        if docker images | grep -q "${{ env.REDIS_IMAGE_NAME }}"; then
          echo "ğŸš€ Pushing custom Redis image..."
          docker push ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:latest
          docker push ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:${{ github.sha }}
        fi
        
        if docker images | grep -q "${{ env.POSTGRESQL_IMAGE_NAME }}"; then
          echo "ğŸš€ Pushing custom PostgreSQL image..."
          docker push ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:latest
          docker push ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:${{ github.sha }}
        fi

    - name: Move cache
      run: |
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true

    - name: Test image health
      run: |
        # Function to find available port
        find_available_port() {
          local port
          for i in {1..10}; do
            port=$((RANDOM % 55000 + 10000))
            if ! netstat -tuln | grep ":$port " > /dev/null 2>&1; then
              echo $port
              return 0
            fi
          done
          echo "Failed to find available port" >&2
          return 1
        }
        
        # Get available port
        TEST_PORT=$(find_available_port)
        echo "Using dynamic port: $TEST_PORT"
        
        # Cleanup any existing test containers
        docker rm -f test-container || true
        
        # Run container with dynamic port
        docker run --rm --name test-container -d -p $TEST_PORT:2542 ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        # Wait for container to be ready with timeout
        echo "Waiting for container to be ready..."
        for i in {1..30}; do
          if curl -sf http://localhost:$TEST_PORT/health > /dev/null 2>&1; then
            echo "Container is ready after ${i} seconds"
            break
          fi
          sleep 1
        done
        
        # Final health check with detailed output
        echo "Testing health endpoint at http://localhost:$TEST_PORT/health"
        if ! curl -f http://localhost:$TEST_PORT/health; then
          echo "Health check failed, showing container logs:"
          docker logs test-container
          exit 1
        fi
        
        echo "âœ… Health check passed"
        
        # Cleanup
        docker stop test-container || true

    - name: Cleanup old images
      run: |
        docker image prune -f
        docker images | grep ${{ env.IMAGE_NAME }} | grep -v latest | head -n -3 | awk '{print $3}' | xargs -r docker rmi || true

    - name: Logout from registry
      if: always()
      run: docker logout ${{ env.REGISTRY }}

    - name: Docker Compose Deployment Notification
      run: |
        echo "ğŸ³ DOCKER COMPOSE ê¸°ë°˜ ë°°í¬ ì™„ë£Œ"
        echo "âœ… Image pushed to registry: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
        echo "ğŸ”„ Watchtower ìë™ ì—…ë°ì´íŠ¸: 1ì‹œê°„ ë‚´ ë°°í¬"
        echo ""
        echo "ğŸ“‹ ì¦‰ì‹œ ìˆ˜ë™ ë°°í¬:"
        echo "  docker-compose pull && docker-compose up -d"
        echo ""
        echo "ğŸ“Š ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸:"
        echo "  docker-compose ps"
        echo "  curl http://localhost:32542/health"
        echo ""
        echo "ğŸ¯ Compose ê¸°ë°˜ ì™„ì „ ì „í™˜ ì™„ë£Œ - K8s ì˜ì¡´ì„± ì œê±°ë¨"