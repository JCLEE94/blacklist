name: Auto Deploy to Registry

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: registry.jclee.me
  IMAGE_NAME: blacklist
  REDIS_IMAGE_NAME: blacklist-redis
  POSTGRESQL_IMAGE_NAME: blacklist-postgresql
  DOCKER_BUILDKIT: 1

jobs:
  build-and-deploy:
    runs-on: self-hosted
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Validate version consistency
      run: |
        if [ -f scripts/version-manager.py ]; then
          python3 scripts/version-manager.py --validate-only --project-root .
        else
          echo "âš ï¸ Version manager not found - skipping validation"
        fi
    
    - name: Bump version
      id: version
      run: |
        chmod +x scripts/bump-version.sh
        ./scripts/bump-version.sh
        echo "VERSION=$(cat version.txt)" >> $GITHUB_ENV
        echo "VERSION=$(cat version.txt)" >> $GITHUB_OUTPUT
        
    - name: Show version references
      run: |
        echo "ğŸ“‹ Updated version references:"
        if [ -f scripts/version-manager.py ]; then
          python3 scripts/version-manager.py --show-references --project-root . | head -20
        fi
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: network=host
        
    - name: Debug build environment
      run: |
        echo "ğŸ” Debugging build environment..."
        echo "Current directory: $(pwd)"
        echo "Available files in root:"
        ls -la
        echo ""
        echo "Docker version:"
        docker --version
        echo ""
        echo "Docker Buildx version:"
        docker buildx version
        echo ""
        echo "Checking critical files:"
        echo "- config/requirements.txt: $([ -f config/requirements.txt ] && echo 'âœ… EXISTS' || echo 'âŒ MISSING')"
        echo "- docker/Dockerfile: $([ -f docker/Dockerfile ] && echo 'âœ… EXISTS' || echo 'âŒ MISSING')"
        echo "- docker/redis/Dockerfile: $([ -f docker/redis/Dockerfile ] && echo 'âœ… EXISTS' || echo 'âŒ MISSING')"
        echo "- docker/postgresql/Dockerfile: $([ -f docker/postgresql/Dockerfile ] && echo 'âœ… EXISTS' || echo 'âŒ MISSING')"
        echo ""
        if [ -f config/requirements.txt ]; then
          echo "requirements.txt size: $(wc -l < config/requirements.txt) lines"
        fi
      
    - name: Cache Docker layers
      uses: actions/cache@v3
      with:
        path: |
          /tmp/.buildx-cache
          /tmp/.buildx-cache-redis
          /tmp/.buildx-cache-postgres
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    - name: Login to Container Registry
      run: |
        echo "ğŸ” Logging into registry: ${{ env.REGISTRY }}"
        
        # Verify secrets are available
        if [ -z "${{ secrets.REGISTRY_USERNAME }}" ]; then
          echo "âŒ Error: REGISTRY_USERNAME secret not set"
          exit 1
        fi
        
        if [ -z "${{ secrets.REGISTRY_PASSWORD }}" ]; then
          echo "âŒ Error: REGISTRY_PASSWORD secret not set"
          exit 1
        fi
        
        # Test registry connectivity first
        echo "Testing registry connectivity..."
        if ! ping -c 3 registry.jclee.me; then
          echo "âŒ Error: Cannot reach registry.jclee.me"
          exit 1
        fi
        
        # Login with error handling
        echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ${{ env.REGISTRY }} -u ${{ secrets.REGISTRY_USERNAME }} --password-stdin
        if [ $? -ne 0 ]; then
          echo "âŒ Failed to login to registry ${{ env.REGISTRY }}"
          echo "Username: ${{ secrets.REGISTRY_USERNAME }}"
          echo "Registry: ${{ env.REGISTRY }}"
          exit 1
        fi
        
        echo "âœ… Successfully logged into registry"

    - name: Build support images first
      run: |
        echo "ğŸ”„ Building support images (Redis, PostgreSQL) first..."
        
        # Build Redis image if configuration exists
        if [ -d docker/redis ] && [ -f docker/redis/Dockerfile ]; then
          echo "ğŸ”´ Building custom Redis image..."
          docker buildx build \
            --platform linux/amd64 \
            --cache-from type=local,src=/tmp/.buildx-cache-redis \
            --cache-to type=local,dest=/tmp/.buildx-cache-redis-new,mode=max \
            -f docker/redis/Dockerfile \
            -t ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:latest \
            -t ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:v${{ env.VERSION }} \
            --load \
            docker/redis/
        else
          echo "â„¹ï¸ No custom Redis configuration found, using public redis:7-alpine"
        fi
        
        # Build PostgreSQL image if configuration exists
        if [ -d docker/postgresql ] && [ -f docker/postgresql/Dockerfile ]; then
          echo "ğŸ˜ Building custom PostgreSQL image..."
          docker buildx build \
            --platform linux/amd64 \
            --cache-from type=local,src=/tmp/.buildx-cache-postgres \
            --cache-to type=local,dest=/tmp/.buildx-cache-postgres-new,mode=max \
            -f docker/postgresql/Dockerfile \
            -t ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:latest \
            -t ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:v${{ env.VERSION }} \
            --load \
            docker/postgresql/
        else
          echo "â„¹ï¸ No custom PostgreSQL configuration found, using public postgres:15-alpine"
        fi

    - name: Build main application image
      run: |
        echo "ğŸ³ Building Blacklist main application image..."
        
        # Verify requirements.txt exists in expected location
        if [ ! -f config/requirements.txt ]; then
          echo "âŒ Error: config/requirements.txt not found"
          echo "Available files in config/:"
          ls -la config/ || echo "config/ directory not found"
          exit 1
        fi
        
        # Build main application with proper dockerfile
        docker buildx build \
          --platform linux/amd64 \
          --cache-from type=local,src=/tmp/.buildx-cache \
          --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
          -f docker/Dockerfile \
          -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
          -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }} \
          --build-arg VERSION=${{ env.VERSION }} \
          --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
          --build-arg VCS_REF=${{ github.sha }} \
          --load \
          .
        
        echo "âœ… Main application image built successfully"

    - name: Push support images to registry
      run: |
        echo "ğŸš€ Pushing support images first..."
        
        # Push Redis image if built
        if docker images | grep -q "${{ env.REDIS_IMAGE_NAME }}"; then
          echo "ğŸ”´ Pushing custom Redis image..."
          docker push ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:latest
          docker push ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:v${{ env.VERSION }}
          echo "âœ… Redis image pushed successfully"
        fi
        
        # Push PostgreSQL image if built
        if docker images | grep -q "${{ env.POSTGRESQL_IMAGE_NAME }}"; then
          echo "ğŸ˜ Pushing custom PostgreSQL image..."
          docker push ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:latest
          docker push ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:v${{ env.VERSION }}
          echo "âœ… PostgreSQL image pushed successfully"
        fi

    - name: Push main application to registry
      run: |
        echo "ğŸš€ Pushing Blacklist main application image..."
        
        # Verify images exist before pushing
        if ! docker images | grep -q "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"; then
          echo "âŒ Error: Main application image not found"
          docker images | grep "${{ env.IMAGE_NAME }}" || echo "No images with name ${{ env.IMAGE_NAME }}"
          exit 1
        fi
        
        # Push with error handling
        echo "Pushing latest tag..."
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest || {
          echo "Failed to push latest tag"
          exit 1
        }
        
        echo "Pushing SHA tag..."
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} || {
          echo "Failed to push SHA tag"
          exit 1
        }
        
        echo "Pushing version tag..."
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }} || {
          echo "Failed to push version tag"
          exit 1
        }
        
        echo "âœ… All main application images pushed successfully"

    - name: Move build caches
      run: |
        echo "ğŸ—‚ï¸ Managing build caches..."
        
        # Move main cache
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true
        
        # Move Redis cache if exists
        if [ -d "/tmp/.buildx-cache-redis-new" ]; then
          rm -rf /tmp/.buildx-cache-redis
          mv /tmp/.buildx-cache-redis-new /tmp/.buildx-cache-redis
        fi
        
        # Move PostgreSQL cache if exists
        if [ -d "/tmp/.buildx-cache-postgres-new" ]; then
          rm -rf /tmp/.buildx-cache-postgres
          mv /tmp/.buildx-cache-postgres-new /tmp/.buildx-cache-postgres
        fi
        
        echo "âœ… Build caches updated successfully"

    - name: Test image health
      run: |
        echo "ğŸ¥ Testing application image health..."
        
        # Use fixed port for testing to avoid conflicts
        TEST_PORT=45678
        
        # Cleanup any existing test containers
        echo "ğŸ§¹ Cleaning up existing test containers..."
        docker rm -f test-blacklist-container || true
        docker rm -f test-redis-container || true  
        docker rm -f test-postgres-container || true
        docker network rm test-blacklist-network || true
        
        # Create test network
        echo "ğŸŒ Creating test network..."
        docker network create test-blacklist-network
        
        # Start minimal Redis for testing
        echo "ğŸ”´ Starting test Redis..."
        docker run -d --name test-redis-container --network test-blacklist-network \
          -e REDIS_MAXMEMORY=64mb \
          redis:7-alpine redis-server --maxmemory 64mb --maxmemory-policy allkeys-lru
        
        # Start minimal PostgreSQL for testing  
        echo "ğŸ˜ Starting test PostgreSQL..."
        docker run -d --name test-postgres-container --network test-blacklist-network \
          -e POSTGRES_DB=blacklist \
          -e POSTGRES_USER=blacklist_user \
          -e POSTGRES_PASSWORD=test_password123 \
          postgres:15-alpine
        
        # Wait for services to be ready
        echo "â³ Waiting for test services to start..."
        sleep 15
        
        # Test service connectivity
        echo "ğŸ” Testing service connectivity..."
        docker exec test-redis-container redis-cli ping || {
          echo "âŒ Redis container health check failed"
          docker logs test-redis-container
          exit 1
        }
        
        docker exec test-postgres-container pg_isready -U blacklist_user -d blacklist || {
          echo "âŒ PostgreSQL container health check failed" 
          docker logs test-postgres-container
          exit 1
        }
        
        # Run container with test environment
        echo "ğŸ³ Starting test Blacklist container..."
        docker run --rm --name test-blacklist-container -d \
          --network test-blacklist-network \
          -p $TEST_PORT:2542 \
          -e DATABASE_URL="postgresql://blacklist_user:test_password123@test-postgres-container:5432/blacklist" \
          -e REDIS_URL="redis://test-redis-container:6379/0" \
          -e FLASK_ENV=production \
          -e COLLECTION_ENABLED=false \
          -e FORCE_DISABLE_COLLECTION=true \
          -e SECRET_KEY=test-secret-key \
          -e JWT_SECRET_KEY=test-jwt-secret \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        # Wait for container to be ready with timeout
        echo "â³ Waiting for Blacklist container to be ready (max 90s)..."
        READY=false
        for i in {1..90}; do
          if curl -sf http://localhost:$TEST_PORT/health > /dev/null 2>&1; then
            echo "âœ… Container is ready after ${i} seconds"
            READY=true
            break
          fi
          if [ $((i % 15)) -eq 0 ]; then
            echo "âš ï¸ Still waiting... (${i}s elapsed)"
            docker logs --tail=10 test-blacklist-container || true
          fi
          sleep 1
        done
        
        if [ "$READY" = false ]; then
          echo "âŒ Container failed to become ready within 90 seconds"
          echo ""
          echo "ğŸ” Container logs:"
          docker logs test-blacklist-container || true
          echo ""
          echo "ğŸ” Network information:"
          docker network inspect test-blacklist-network || true
          exit 1
        fi
        
        # Comprehensive health check
        echo "ğŸ” Running comprehensive health checks..."
        
        # Basic health endpoint
        echo "Testing basic health endpoint..."
        if ! curl -f http://localhost:$TEST_PORT/health; then
          echo ""
          echo "âŒ Basic health check failed"
          echo "ğŸ” Container logs:"
          docker logs test-blacklist-container
          exit 1
        fi
        
        # Test detailed health endpoint (if available)
        echo ""
        echo "Testing detailed health endpoint..."
        curl -f http://localhost:$TEST_PORT/api/health 2>/dev/null || echo "â„¹ï¸ Detailed health endpoint not available"
        
        # Test readiness endpoint
        echo ""
        echo "Testing readiness endpoint..."
        curl -f http://localhost:$TEST_PORT/ready 2>/dev/null || echo "â„¹ï¸ Readiness endpoint not available"
        
        echo ""
        echo "âœ… All health checks passed successfully"
        
        # Cleanup
        echo ""
        echo "ğŸ§¹ Cleaning up test containers..."
        docker stop test-blacklist-container || true
        docker stop test-redis-container || true
        docker stop test-postgres-container || true
        docker rm test-redis-container || true
        docker rm test-postgres-container || true
        docker network rm test-blacklist-network || true
        
        echo "âœ… Health test completed successfully"

    - name: Create GitHub Release
      if: env.VERSION != ''
      continue-on-error: true
      run: |
        echo "ğŸ¯ Attempting to create GitHub Release v${{ env.VERSION }}"
        
        # Try to create release using GitHub CLI - continue if it fails
        if gh release create "v${{ env.VERSION }}" \
          --title "Release v${{ env.VERSION }}" \
          --notes "ğŸš€ **Blacklist Management System v${{ env.VERSION }}**

        **ğŸ“¦ Docker Images:**
        - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }}\`
        - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\`
        - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}\`

        **ğŸ” Changes:**
        Automated release with comprehensive version management and fixed Docker build pipeline.

        **ğŸ“Š Deployment:**
        - Live System: https://blacklist.jclee.me/
        - Health Check: https://blacklist.jclee.me/health
        - Documentation: https://jclee94.github.io/blacklist/

        **ğŸ”§ Installation:**
        \`\`\`bash
        docker-compose pull && docker-compose up -d
        \`\`\`

        **ğŸ› ï¸ Fixed Issues:**
        - Updated GitHub Actions workflow to use modern release creation
        - Optimized Docker build pipeline
        - Fixed application entry point paths
        - Enhanced error handling and logging" \
          --latest 2>/dev/null; then
          echo "âœ… GitHub Release v${{ env.VERSION }} created successfully"
        else
          echo "âš ï¸ GitHub Release creation failed - continuing deployment (this is non-critical)"
          echo "ğŸ“ Manual release can be created later with tag v${{ env.VERSION }}"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Cleanup old images
      run: |
        docker image prune -f
        docker images | grep ${{ env.IMAGE_NAME }} | grep -v latest | head -n -3 | awk '{print $3}' | xargs -r docker rmi || true

    - name: Logout from registry
      if: always()
      run: docker logout ${{ env.REGISTRY }}

    - name: Final deployment summary
      run: |
        echo "ğŸ‰ CI/CD PIPELINE ì™„ë£Œ - v${{ env.VERSION }}"
        echo "========================================================================================"
        echo ""
        echo "ğŸ“¦ ë¹Œë“œëœ ì´ë¯¸ì§€ë“¤:"
        echo "   âœ… ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
        echo "   âœ… ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }}"
        echo "   âœ… ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
        
        # Check if support images were built
        if docker images | grep -q "${{ env.REDIS_IMAGE_NAME }}"; then
          echo "   âœ… ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:latest"
        fi
        
        if docker images | grep -q "${{ env.POSTGRESQL_IMAGE_NAME }}"; then
          echo "   âœ… ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:latest"
        fi
        
        echo ""
        echo "ğŸš€ ë°°í¬ ì˜µì…˜:"
        echo "   ğŸ”„ Watchtower ìë™ ì—…ë°ì´íŠ¸: 1ì‹œê°„ ë‚´"
        echo "   âš¡ ì¦‰ì‹œ ìˆ˜ë™ ë°°í¬: docker-compose pull && docker-compose up -d"
        echo ""
        echo "ğŸ” ëª¨ë‹ˆí„°ë§ ëª…ë ¹ì–´:"
        echo "   ğŸ“Š ìƒíƒœ í™•ì¸: docker-compose ps"
        echo "   ğŸ¥ í—¬ìŠ¤ì²´í¬: curl http://localhost:32542/health"
        echo "   ğŸ“œ ë¡œê·¸ í™•ì¸: docker-compose logs -f blacklist"
        echo ""
        echo "ğŸŒ ì„œë¹„ìŠ¤ ì—”ë“œí¬ì¸íŠ¸:"
        echo "   ğŸ  Local: http://localhost:32542"
        echo "   ğŸŒ Production: https://blacklist.jclee.me"
        echo "   ğŸ“– Portfolio: https://jclee94.github.io/blacklist"
        echo ""
        echo "ğŸ¯ ë¦´ë¦¬ìŠ¤ ì •ë³´:"
        echo "   ğŸ“‹ Release Notes: https://github.com/${{ github.repository }}/releases/tag/v${{ env.VERSION }}"
        echo "   ğŸ“¦ Registry: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
        echo "   ğŸ”– Version: v${{ env.VERSION }}"
        echo "   ğŸ“… Build Time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
        echo ""
        echo "âœ… CI/CD íŒŒì´í”„ë¼ì¸ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!"
        echo "========================================================================================"

    - name: Run post-deployment verification
      run: |
        echo "ğŸ” Running post-deployment verification..."
        
        # Make verification script executable
        chmod +x scripts/post-deploy-verification.sh
        
        # Run verification with timeout
        if timeout 300 bash scripts/post-deploy-verification.sh; then
          echo "âœ… Post-deployment verification passed"
        else
          echo "âŒ Post-deployment verification failed or timed out"
          echo "â„¹ï¸ This may be normal if services need more time to start"
          # Don't fail the entire workflow for verification issues
        fi