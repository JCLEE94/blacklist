name: Auto Deploy to Registry

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: registry.jclee.me
  IMAGE_NAME: blacklist
  REDIS_IMAGE_NAME: blacklist-redis
  POSTGRESQL_IMAGE_NAME: blacklist-postgresql
  DOCKER_BUILDKIT: 1

jobs:
  build-and-deploy:
    runs-on: self-hosted
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Validate version consistency
      run: |
        if [ -f scripts/version-manager.py ]; then
          python3 scripts/version-manager.py --validate-only --project-root .
        else
          echo "‚ö†Ô∏è Version manager not found - skipping validation"
        fi
    
    - name: Get current version
      id: version
      run: |
        echo "VERSION=$(cat version.txt)" >> $GITHUB_ENV
        echo "VERSION=$(cat version.txt)" >> $GITHUB_OUTPUT
        echo "üìç Current version: $(cat version.txt)"
        
    - name: Show version references
      run: |
        echo "üìã Updated version references:"
        if [ -f scripts/version-manager.py ]; then
          python3 scripts/version-manager.py --show-references --project-root . | head -20
        fi
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: network=host
        
    - name: Debug build environment
      run: |
        echo "üîç Debugging build environment..."
        echo "Current directory: $(pwd)"
        echo "Available files in root:"
        ls -la
        echo ""
        echo "Docker version:"
        docker --version
        echo ""
        echo "Docker Buildx version:"
        docker buildx version
        echo ""
        echo "Checking critical files:"
        echo "- config/requirements.txt: $([ -f config/requirements.txt ] && echo '‚úÖ EXISTS' || echo '‚ùå MISSING')"
        echo "- build/docker/Dockerfile: $([ -f build/docker/Dockerfile ] && echo '‚úÖ EXISTS' || echo '‚ùå MISSING')"
        echo "- docker/redis/Dockerfile: $([ -f docker/redis/Dockerfile ] && echo '‚úÖ EXISTS' || echo '‚ùå MISSING')"
        echo "- docker/postgresql/Dockerfile: $([ -f docker/postgresql/Dockerfile ] && echo '‚úÖ EXISTS' || echo '‚ùå MISSING')"
        echo ""
        if [ -f config/requirements.txt ]; then
          echo "requirements.txt size: $(wc -l < config/requirements.txt) lines"
        fi
      
    - name: Cache Docker layers
      uses: actions/cache@v3
      with:
        path: |
          /tmp/.buildx-cache
          /tmp/.buildx-cache-redis
          /tmp/.buildx-cache-postgres
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    - name: Login to Container Registry
      run: |
        echo "üîê Logging into registry: ${{ env.REGISTRY }}"
        
        # Verify secrets are available
        if [ -z "${{ secrets.REGISTRY_USERNAME }}" ]; then
          echo "‚ùå Error: REGISTRY_USERNAME secret not set"
          exit 1
        fi
        
        if [ -z "${{ secrets.REGISTRY_PASSWORD }}" ]; then
          echo "‚ùå Error: REGISTRY_PASSWORD secret not set"
          exit 1
        fi
        
        # Test registry connectivity first
        echo "Testing registry connectivity..."
        if ! ping -c 3 registry.jclee.me; then
          echo "‚ùå Error: Cannot reach registry.jclee.me"
          exit 1
        fi
        
        # Login with error handling
        echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ${{ env.REGISTRY }} -u ${{ secrets.REGISTRY_USERNAME }} --password-stdin
        if [ $? -ne 0 ]; then
          echo "‚ùå Failed to login to registry ${{ env.REGISTRY }}"
          echo "Username: ${{ secrets.REGISTRY_USERNAME }}"
          echo "Registry: ${{ env.REGISTRY }}"
          exit 1
        fi
        
        echo "‚úÖ Successfully logged into registry"

    - name: Build support images first
      run: |
        echo "üîÑ Building support images (Redis, PostgreSQL) first..."
        
        # Build Redis image if configuration exists
        if [ -d docker/redis ] && [ -f docker/redis/Dockerfile ]; then
          echo "üî¥ Building custom Redis image..."
          docker buildx build \
            --platform linux/amd64 \
            --cache-from type=local,src=/tmp/.buildx-cache-redis \
            --cache-to type=local,dest=/tmp/.buildx-cache-redis-new,mode=max \
            -f docker/redis/Dockerfile \
            -t ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:latest \
            -t ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:v${{ env.VERSION }} \
            --load \
            docker/redis/
        else
          echo "‚ÑπÔ∏è No custom Redis configuration found, using public redis:7-alpine"
        fi
        
        # Build PostgreSQL image if configuration exists
        if [ -d docker/postgresql ] && [ -f docker/postgresql/Dockerfile ]; then
          echo "üêò Building custom PostgreSQL image..."
          docker buildx build \
            --platform linux/amd64 \
            --cache-from type=local,src=/tmp/.buildx-cache-postgres \
            --cache-to type=local,dest=/tmp/.buildx-cache-postgres-new,mode=max \
            -f docker/postgresql/Dockerfile \
            -t ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:latest \
            -t ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:v${{ env.VERSION }} \
            --load \
            docker/postgresql/
        else
          echo "‚ÑπÔ∏è No custom PostgreSQL configuration found, using public postgres:15-alpine"
        fi

    - name: Build main application image
      run: |
        echo "üê≥ Building Blacklist main application image..."
        
        # Verify requirements.txt exists in expected location
        if [ ! -f config/requirements.txt ]; then
          echo "‚ùå Error: config/requirements.txt not found"
          echo "Available files in config/:"
          ls -la config/ || echo "config/ directory not found"
          exit 1
        fi
        
        # Build main application with proper dockerfile
        docker buildx build \
          --platform linux/amd64 \
          --cache-from type=local,src=/tmp/.buildx-cache \
          --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
          -f build/docker/Dockerfile \
          -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
          -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }} \
          --build-arg VERSION=${{ env.VERSION }} \
          --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
          --build-arg VCS_REF=${{ github.sha }} \
          --load \
          .
        
        echo "‚úÖ Main application image built successfully"

    - name: Push support images to registry
      run: |
        echo "üöÄ Pushing support images first..."
        
        # Push Redis image if built
        if docker images | grep -q "${{ env.REDIS_IMAGE_NAME }}"; then
          echo "üî¥ Pushing custom Redis image..."
          docker push ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:latest
          docker push ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:v${{ env.VERSION }}
          echo "‚úÖ Redis image pushed successfully"
        fi
        
        # Push PostgreSQL image if built
        if docker images | grep -q "${{ env.POSTGRESQL_IMAGE_NAME }}"; then
          echo "üêò Pushing custom PostgreSQL image..."
          docker push ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:latest
          docker push ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:v${{ env.VERSION }}
          echo "‚úÖ PostgreSQL image pushed successfully"
        fi

    - name: Push main application to registry
      run: |
        echo "üöÄ Pushing Blacklist main application image..."
        
        # Verify images exist before pushing
        if ! docker images | grep -q "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"; then
          echo "‚ùå Error: Main application image not found"
          docker images | grep "${{ env.IMAGE_NAME }}" || echo "No images with name ${{ env.IMAGE_NAME }}"
          exit 1
        fi
        
        # Push with error handling
        echo "Pushing latest tag..."
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest || {
          echo "Failed to push latest tag"
          exit 1
        }
        
        echo "Pushing SHA tag..."
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} || {
          echo "Failed to push SHA tag"
          exit 1
        }
        
        echo "Pushing version tag..."
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }} || {
          echo "Failed to push version tag"
          exit 1
        }
        
        echo "‚úÖ All main application images pushed successfully"

    - name: Move build caches
      run: |
        echo "üóÇÔ∏è Managing build caches..."
        
        # Move main cache
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true
        
        # Move Redis cache if exists
        if [ -d "/tmp/.buildx-cache-redis-new" ]; then
          rm -rf /tmp/.buildx-cache-redis
          mv /tmp/.buildx-cache-redis-new /tmp/.buildx-cache-redis
        fi
        
        # Move PostgreSQL cache if exists
        if [ -d "/tmp/.buildx-cache-postgres-new" ]; then
          rm -rf /tmp/.buildx-cache-postgres
          mv /tmp/.buildx-cache-postgres-new /tmp/.buildx-cache-postgres
        fi
        
        echo "‚úÖ Build caches updated successfully"

    - name: Verify built image version
      run: |
        echo "üîç Verifying built Docker image version..."
        
        # Check version in the built image
        echo "üì¶ Checking version in Docker image..."
        docker run --rm ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }} python -c "import sys; sys.path.append('/app'); version_file = '/app/version.txt'; expected = '${{ env.VERSION }}'; version = open(version_file).read().strip(); print(f'Image version: {version}'); assert version == expected, f'Version mismatch: {version} != {expected}'; print('‚úÖ Version matches: ' + version)"
        
        # Test if container starts and responds
        echo "üê≥ Testing container startup..."
        TEST_PORT=45679
        docker run -d --rm --name version-test-container \
          -p $TEST_PORT:2542 \
          -e FLASK_ENV=production \
          -e COLLECTION_ENABLED=false \
          -e FORCE_DISABLE_COLLECTION=true \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }}
        
        # Wait for container to start
        echo "‚è≥ Waiting for container to start (max 30s)..."
        for i in {1..30}; do
          if curl -sf http://localhost:$TEST_PORT/health 2>/dev/null | grep -q "status"; then
            echo "‚úÖ Container is responding"
            
            # Check version in health endpoint
            VERSION_IN_HEALTH=$(curl -s http://localhost:$TEST_PORT/health 2>/dev/null | grep -o '"version":"[^"]*"' | cut -d'"' -f4 || echo "unknown")
            echo "üìã Version in /health endpoint: $VERSION_IN_HEALTH"
            
            if [ "$VERSION_IN_HEALTH" = "${{ env.VERSION }}" ]; then
              echo "‚úÖ Version verification PASSED: v${{ env.VERSION }}"
            else
              echo "‚ö†Ô∏è Version in health endpoint doesn't match (expected: ${{ env.VERSION }}, got: $VERSION_IN_HEALTH)"
            fi
            break
          fi
          sleep 1
        done
        
        # Cleanup
        docker stop version-test-container 2>/dev/null || true
        echo "‚úÖ Image version verification completed"

    - name: Test image health
      run: |
        echo "üè• Testing application image health..."
        
        # Use fixed port for testing to avoid conflicts
        TEST_PORT=45678
        
        # Cleanup any existing test containers
        echo "üßπ Cleaning up existing test containers..."
        docker rm -f test-blacklist-container || true
        docker rm -f test-redis-container || true  
        docker rm -f test-postgres-container || true
        docker network rm test-blacklist-network || true
        
        # Create test network
        echo "üåê Creating test network..."
        docker network create test-blacklist-network
        
        # Start minimal Redis for testing
        echo "üî¥ Starting test Redis..."
        docker run -d --name test-redis-container --network test-blacklist-network \
          -e REDIS_MAXMEMORY=64mb \
          redis:7-alpine redis-server --maxmemory 64mb --maxmemory-policy allkeys-lru
        
        # Start minimal PostgreSQL for testing  
        echo "üêò Starting test PostgreSQL..."
        docker run -d --name test-postgres-container --network test-blacklist-network \
          -e POSTGRES_DB=blacklist \
          -e POSTGRES_USER=blacklist_user \
          -e POSTGRES_PASSWORD=test_password123 \
          postgres:15-alpine
        
        # Wait for services to be ready
        echo "‚è≥ Waiting for test services to start..."
        sleep 15
        
        # Test service connectivity
        echo "üîç Testing service connectivity..."
        docker exec test-redis-container redis-cli ping || {
          echo "‚ùå Redis container health check failed"
          docker logs test-redis-container
          exit 1
        }
        
        docker exec test-postgres-container pg_isready -U blacklist_user -d blacklist || {
          echo "‚ùå PostgreSQL container health check failed" 
          docker logs test-postgres-container
          exit 1
        }
        
        # Run container with test environment
        echo "üê≥ Starting test Blacklist container..."
        docker run --rm --name test-blacklist-container -d \
          --network test-blacklist-network \
          -p $TEST_PORT:2542 \
          -e DATABASE_URL="postgresql://blacklist_user:test_password123@test-postgres-container:5432/blacklist" \
          -e REDIS_URL="redis://test-redis-container:6379/0" \
          -e FLASK_ENV=production \
          -e COLLECTION_ENABLED=false \
          -e FORCE_DISABLE_COLLECTION=true \
          -e SECRET_KEY=test-secret-key \
          -e JWT_SECRET_KEY=test-jwt-secret \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        # Wait for container to be ready with timeout
        echo "‚è≥ Waiting for Blacklist container to be ready (max 90s)..."
        READY=false
        for i in {1..90}; do
          if curl -sf http://localhost:$TEST_PORT/health > /dev/null 2>&1; then
            echo "‚úÖ Container is ready after ${i} seconds"
            READY=true
            break
          fi
          if [ $((i % 15)) -eq 0 ]; then
            echo "‚ö†Ô∏è Still waiting... (${i}s elapsed)"
            docker logs --tail=10 test-blacklist-container || true
          fi
          sleep 1
        done
        
        if [ "$READY" = false ]; then
          echo "‚ùå Container failed to become ready within 90 seconds"
          echo ""
          echo "üîç Container logs:"
          docker logs test-blacklist-container || true
          echo ""
          echo "üîç Network information:"
          docker network inspect test-blacklist-network || true
          exit 1
        fi
        
        # Comprehensive health check
        echo "üîç Running comprehensive health checks..."
        
        # Basic health endpoint
        echo "Testing basic health endpoint..."
        if ! curl -f http://localhost:$TEST_PORT/health; then
          echo ""
          echo "‚ùå Basic health check failed"
          echo "üîç Container logs:"
          docker logs test-blacklist-container
          exit 1
        fi
        
        # Test detailed health endpoint (if available)
        echo ""
        echo "Testing detailed health endpoint..."
        curl -f http://localhost:$TEST_PORT/api/health 2>/dev/null || echo "‚ÑπÔ∏è Detailed health endpoint not available"
        
        # Test readiness endpoint
        echo ""
        echo "Testing readiness endpoint..."
        curl -f http://localhost:$TEST_PORT/ready 2>/dev/null || echo "‚ÑπÔ∏è Readiness endpoint not available"
        
        echo ""
        echo "‚úÖ All health checks passed successfully"
        
        # Cleanup
        echo ""
        echo "üßπ Cleaning up test containers..."
        docker stop test-blacklist-container || true
        docker stop test-redis-container || true
        docker stop test-postgres-container || true
        docker rm test-redis-container || true
        docker rm test-postgres-container || true
        docker network rm test-blacklist-network || true
        
        echo "‚úÖ Health test completed successfully"

    - name: Create GitHub Release
      if: env.VERSION != ''
      continue-on-error: true
      run: |
        echo "üéØ Attempting to create GitHub Release v${{ env.VERSION }}"
        
        # Try to create release using GitHub CLI - continue if it fails
        if gh release create "v${{ env.VERSION }}" \
          --title "Release v${{ env.VERSION }}" \
          --notes "üöÄ **Blacklist Management System v${{ env.VERSION }}**

        **üì¶ Docker Images:**
        - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }}\`
        - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\`
        - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}\`

        **üîç Changes:**
        Automated release with comprehensive version management and fixed Docker build pipeline.

        **üìä Deployment:**
        - Live System: https://blacklist.jclee.me/
        - Health Check: https://blacklist.jclee.me/health
        - Documentation: https://jclee94.github.io/blacklist/

        **üîß Installation:**
        \`\`\`bash
        docker-compose pull && docker-compose up -d
        \`\`\`

        **üõ†Ô∏è Fixed Issues:**
        - Updated GitHub Actions workflow to use modern release creation
        - Optimized Docker build pipeline
        - Fixed application entry point paths
        - Enhanced error handling and logging" \
          --latest 2>/dev/null; then
          echo "‚úÖ GitHub Release v${{ env.VERSION }} created successfully"
        else
          echo "‚ö†Ô∏è GitHub Release creation failed - continuing deployment (this is non-critical)"
          echo "üìù Manual release can be created later with tag v${{ env.VERSION }}"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Cleanup old images
      run: |
        docker image prune -f
        docker images | grep ${{ env.IMAGE_NAME }} | grep -v latest | head -n -3 | awk '{print $3}' | xargs -r docker rmi || true

    - name: Logout from registry
      if: always()
      run: docker logout ${{ env.REGISTRY }}

    - name: Final deployment summary
      run: |
        echo "üéâ CI/CD PIPELINE ÏôÑÎ£å - v${{ env.VERSION }}"
        echo "========================================================================================"
        echo ""
        echo "üì¶ ÎπåÎìúÎêú Ïù¥ÎØ∏ÏßÄÎì§:"
        echo "   ‚úÖ ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
        echo "   ‚úÖ ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }}"
        echo "   ‚úÖ ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
        
        # Check if support images were built
        if docker images | grep -q "${{ env.REDIS_IMAGE_NAME }}"; then
          echo "   ‚úÖ ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:latest"
        fi
        
        if docker images | grep -q "${{ env.POSTGRESQL_IMAGE_NAME }}"; then
          echo "   ‚úÖ ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:latest"
        fi
        
        echo ""
        echo "üöÄ Î∞∞Ìè¨ ÏòµÏÖò:"
        echo "   üîÑ Watchtower ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏: 1ÏãúÍ∞Ñ ÎÇ¥"
        echo "   ‚ö° Ï¶âÏãú ÏàòÎèô Î∞∞Ìè¨: docker-compose pull && docker-compose up -d"
        echo ""
        echo "üîç Î™®ÎãàÌÑ∞ÎßÅ Î™ÖÎ†πÏñ¥:"
        echo "   üìä ÏÉÅÌÉú ÌôïÏù∏: docker-compose ps"
        echo "   üè• Ìó¨Ïä§Ï≤¥ÌÅ¨: curl http://localhost:32542/health"
        echo "   üìú Î°úÍ∑∏ ÌôïÏù∏: docker-compose logs -f blacklist"
        echo ""
        echo "üåê ÏÑúÎπÑÏä§ ÏóîÎìúÌè¨Ïù∏Ìä∏:"
        echo "   üè† Local: http://localhost:32542"
        echo "   üåç Production: https://blacklist.jclee.me"
        echo "   üìñ Portfolio: https://jclee94.github.io/blacklist"
        echo ""
        echo "üéØ Î¶¥Î¶¨Ïä§ Ï†ïÎ≥¥:"
        echo "   üìã Release Notes: https://github.com/${{ github.repository }}/releases/tag/v${{ env.VERSION }}"
        echo "   üì¶ Registry: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
        echo "   üîñ Version: v${{ env.VERSION }}"
        echo "   üìÖ Build Time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
        echo ""
        echo "‚úÖ CI/CD ÌååÏù¥ÌîÑÎùºÏù∏Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!"
        echo "========================================================================================"

    - name: Verify deployment on blacklist.jclee.me
      run: |
        echo "üîç Checking if blacklist.jclee.me updated to v${{ env.VERSION }}..."
        
        # Check live site version (wait up to 5 minutes)
        MAX_ATTEMPTS=10
        WAIT_TIME=30
        SUCCESS=false
        
        for i in $(seq 1 $MAX_ATTEMPTS); do
          echo "üîÑ Attempt $i/$MAX_ATTEMPTS: Checking live site..."
          
          # Try to get version from health endpoint
          LIVE_VERSION=$(curl -s https://blacklist.jclee.me/health 2>/dev/null | grep -o '"version":"[^"]*"' | cut -d'"' -f4 || echo "error")
          
          if [ "$LIVE_VERSION" = "${{ env.VERSION }}" ]; then
            echo "‚úÖ SUCCESS! blacklist.jclee.me is running v${{ env.VERSION }}"
            SUCCESS=true
            break
          elif [ "$LIVE_VERSION" = "error" ]; then
            echo "‚ùå Site not responding or error getting version"
          else
            echo "‚ö†Ô∏è Version mismatch - Expected: ${{ env.VERSION }}, Found: $LIVE_VERSION"
          fi
          
          if [ $i -lt $MAX_ATTEMPTS ]; then
            echo "‚è≥ Waiting ${WAIT_TIME}s before next check..."
            sleep $WAIT_TIME
          fi
        done
        
        if [ "$SUCCESS" = true ]; then
          echo "üéâ Deployment verification PASSED - blacklist.jclee.me is running v${{ env.VERSION }}"
        else
          echo "‚ùå Deployment verification FAILED - blacklist.jclee.me is NOT running v${{ env.VERSION }}"
          echo "‚ö†Ô∏è This could mean:"
          echo "   - Watchtower hasn't deployed yet (wait 1 hour)"
          echo "   - Site is down (502 error)"
          echo "   - Manual intervention needed"
        fi

