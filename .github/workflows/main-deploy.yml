name: Auto Deploy to Registry

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: registry.jclee.me
  IMAGE_NAME: blacklist
  REDIS_IMAGE_NAME: blacklist-redis
  POSTGRESQL_IMAGE_NAME: blacklist-postgresql
  DOCKER_BUILDKIT: 1

jobs:
  build-and-deploy:
    runs-on: self-hosted
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Validate version consistency
      run: |
        if [ -f scripts/version-manager.py ]; then
          python3 scripts/version-manager.py --validate-only --project-root .
        else
          echo "‚ö†Ô∏è Version manager not found - skipping validation"
        fi
    
    - name: Bump version
      id: version
      run: |
        chmod +x scripts/bump-version.sh
        ./scripts/bump-version.sh
        echo "VERSION=$(cat version.txt)" >> $GITHUB_ENV
        echo "VERSION=$(cat version.txt)" >> $GITHUB_OUTPUT
        
    - name: Show version references
      run: |
        echo "üìã Updated version references:"
        if [ -f scripts/version-manager.py ]; then
          python3 scripts/version-manager.py --show-references --project-root . | head -20
        fi
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: network=host
        
    - name: Debug build environment
      run: |
        echo "üîç Debugging build environment..."
        echo "Current directory: $(pwd)"
        echo "Available files in root:"
        ls -la
        echo ""
        echo "Docker version:"
        docker --version
        echo ""
        echo "Docker Buildx version:"
        docker buildx version
        echo ""
        echo "Checking critical files:"
        echo "- config/requirements.txt: $([ -f config/requirements.txt ] && echo '‚úÖ EXISTS' || echo '‚ùå MISSING')"
        echo "- docker/Dockerfile: $([ -f docker/Dockerfile ] && echo '‚úÖ EXISTS' || echo '‚ùå MISSING')"
        echo "- docker/redis/Dockerfile: $([ -f docker/redis/Dockerfile ] && echo '‚úÖ EXISTS' || echo '‚ùå MISSING')"
        echo "- docker/postgresql/Dockerfile: $([ -f docker/postgresql/Dockerfile ] && echo '‚úÖ EXISTS' || echo '‚ùå MISSING')"
        echo ""
        if [ -f config/requirements.txt ]; then
          echo "requirements.txt size: $(wc -l < config/requirements.txt) lines"
        fi
      
    - name: Cache Docker layers
      uses: actions/cache@v3
      with:
        path: |
          /tmp/.buildx-cache
          /tmp/.buildx-cache-redis
          /tmp/.buildx-cache-postgres
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    - name: Login to Container Registry
      run: |
        echo "üîê Logging into registry: ${{ env.REGISTRY }}"
        
        # Verify secrets are available
        if [ -z "${{ secrets.REGISTRY_USERNAME }}" ]; then
          echo "‚ùå Error: REGISTRY_USERNAME secret not set"
          exit 1
        fi
        
        if [ -z "${{ secrets.REGISTRY_PASSWORD }}" ]; then
          echo "‚ùå Error: REGISTRY_PASSWORD secret not set"
          exit 1
        fi
        
        # Test registry connectivity first
        echo "Testing registry connectivity..."
        if ! ping -c 3 registry.jclee.me; then
          echo "‚ùå Error: Cannot reach registry.jclee.me"
          exit 1
        fi
        
        # Login with error handling
        echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ${{ env.REGISTRY }} -u ${{ secrets.REGISTRY_USERNAME }} --password-stdin
        if [ $? -ne 0 ]; then
          echo "‚ùå Failed to login to registry ${{ env.REGISTRY }}"
          echo "Username: ${{ secrets.REGISTRY_USERNAME }}"
          echo "Registry: ${{ env.REGISTRY }}"
          exit 1
        fi
        
        echo "‚úÖ Successfully logged into registry"

    - name: Build support images first
      run: |
        echo "üîÑ Building support images (Redis, PostgreSQL) first..."
        
        # Build Redis image if configuration exists
        if [ -d docker/redis ] && [ -f docker/redis/Dockerfile ]; then
          echo "üî¥ Building custom Redis image..."
          docker buildx build \
            --platform linux/amd64 \
            --cache-from type=local,src=/tmp/.buildx-cache-redis \
            --cache-to type=local,dest=/tmp/.buildx-cache-redis-new,mode=max \
            -f docker/redis/Dockerfile \
            -t ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:latest \
            -t ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:v${{ env.VERSION }} \
            --load \
            docker/redis/
        else
          echo "‚ÑπÔ∏è No custom Redis configuration found, using public redis:7-alpine"
        fi
        
        # Build PostgreSQL image if configuration exists
        if [ -d docker/postgresql ] && [ -f docker/postgresql/Dockerfile ]; then
          echo "üêò Building custom PostgreSQL image..."
          docker buildx build \
            --platform linux/amd64 \
            --cache-from type=local,src=/tmp/.buildx-cache-postgres \
            --cache-to type=local,dest=/tmp/.buildx-cache-postgres-new,mode=max \
            -f docker/postgresql/Dockerfile \
            -t ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:latest \
            -t ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:v${{ env.VERSION }} \
            --load \
            docker/postgresql/
        else
          echo "‚ÑπÔ∏è No custom PostgreSQL configuration found, using public postgres:15-alpine"
        fi

    - name: Build main application image
      run: |
        echo "üê≥ Building Blacklist main application image..."
        
        # Verify requirements.txt exists in expected location
        if [ ! -f config/requirements.txt ]; then
          echo "‚ùå Error: config/requirements.txt not found"
          echo "Available files in config/:"
          ls -la config/ || echo "config/ directory not found"
          exit 1
        fi
        
        # Build main application with proper dockerfile
        docker buildx build \
          --platform linux/amd64 \
          --cache-from type=local,src=/tmp/.buildx-cache \
          --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
          -f docker/Dockerfile \
          -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
          -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }} \
          --build-arg VERSION=${{ env.VERSION }} \
          --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
          --build-arg VCS_REF=${{ github.sha }} \
          --load \
          .
        
        echo "‚úÖ Main application image built successfully"

    - name: Push support images to registry
      run: |
        echo "üöÄ Pushing support images first..."
        
        # Push Redis image if built
        if docker images | grep -q "${{ env.REDIS_IMAGE_NAME }}"; then
          echo "üî¥ Pushing custom Redis image..."
          docker push ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:latest
          docker push ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:v${{ env.VERSION }}
          echo "‚úÖ Redis image pushed successfully"
        fi
        
        # Push PostgreSQL image if built
        if docker images | grep -q "${{ env.POSTGRESQL_IMAGE_NAME }}"; then
          echo "üêò Pushing custom PostgreSQL image..."
          docker push ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:latest
          docker push ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:v${{ env.VERSION }}
          echo "‚úÖ PostgreSQL image pushed successfully"
        fi

    - name: Push main application to registry
      run: |
        echo "üöÄ Pushing Blacklist main application image..."
        
        # Verify images exist before pushing
        if ! docker images | grep -q "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"; then
          echo "‚ùå Error: Main application image not found"
          docker images | grep "${{ env.IMAGE_NAME }}" || echo "No images with name ${{ env.IMAGE_NAME }}"
          exit 1
        fi
        
        # Push with error handling
        echo "Pushing latest tag..."
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest || {
          echo "Failed to push latest tag"
          exit 1
        }
        
        echo "Pushing SHA tag..."
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} || {
          echo "Failed to push SHA tag"
          exit 1
        }
        
        echo "Pushing version tag..."
        docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }} || {
          echo "Failed to push version tag"
          exit 1
        }
        
        echo "‚úÖ All main application images pushed successfully"

    - name: Move build caches
      run: |
        echo "üóÇÔ∏è Managing build caches..."
        
        # Move main cache
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true
        
        # Move Redis cache if exists
        if [ -d "/tmp/.buildx-cache-redis-new" ]; then
          rm -rf /tmp/.buildx-cache-redis
          mv /tmp/.buildx-cache-redis-new /tmp/.buildx-cache-redis
        fi
        
        # Move PostgreSQL cache if exists
        if [ -d "/tmp/.buildx-cache-postgres-new" ]; then
          rm -rf /tmp/.buildx-cache-postgres
          mv /tmp/.buildx-cache-postgres-new /tmp/.buildx-cache-postgres
        fi
        
        echo "‚úÖ Build caches updated successfully"

    - name: Test image health
      run: |
        echo "üè• Testing application image health..."
        
        # Use fixed port for testing to avoid conflicts
        TEST_PORT=45678
        
        # Cleanup any existing test containers
        echo "üßπ Cleaning up existing test containers..."
        docker rm -f test-blacklist-container || true
        docker rm -f test-redis-container || true  
        docker rm -f test-postgres-container || true
        docker network rm test-blacklist-network || true
        
        # Create test network
        echo "üåê Creating test network..."
        docker network create test-blacklist-network
        
        # Start minimal Redis for testing
        echo "üî¥ Starting test Redis..."
        docker run -d --name test-redis-container --network test-blacklist-network \
          -e REDIS_MAXMEMORY=64mb \
          redis:7-alpine redis-server --maxmemory 64mb --maxmemory-policy allkeys-lru
        
        # Start minimal PostgreSQL for testing  
        echo "üêò Starting test PostgreSQL..."
        docker run -d --name test-postgres-container --network test-blacklist-network \
          -e POSTGRES_DB=blacklist \
          -e POSTGRES_USER=blacklist_user \
          -e POSTGRES_PASSWORD=test_password123 \
          postgres:15-alpine
        
        # Wait for services to be ready
        echo "‚è≥ Waiting for test services to start..."
        sleep 15
        
        # Test service connectivity
        echo "üîç Testing service connectivity..."
        docker exec test-redis-container redis-cli ping || {
          echo "‚ùå Redis container health check failed"
          docker logs test-redis-container
          exit 1
        }
        
        docker exec test-postgres-container pg_isready -U blacklist_user -d blacklist || {
          echo "‚ùå PostgreSQL container health check failed" 
          docker logs test-postgres-container
          exit 1
        }
        
        # Run container with test environment
        echo "üê≥ Starting test Blacklist container..."
        docker run --rm --name test-blacklist-container -d \
          --network test-blacklist-network \
          -p $TEST_PORT:2542 \
          -e DATABASE_URL="postgresql://blacklist_user:test_password123@test-postgres-container:5432/blacklist" \
          -e REDIS_URL="redis://test-redis-container:6379/0" \
          -e FLASK_ENV=production \
          -e COLLECTION_ENABLED=false \
          -e FORCE_DISABLE_COLLECTION=true \
          -e SECRET_KEY=test-secret-key \
          -e JWT_SECRET_KEY=test-jwt-secret \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
        
        # Wait for container to be ready with timeout
        echo "‚è≥ Waiting for Blacklist container to be ready (max 90s)..."
        READY=false
        for i in {1..90}; do
          if curl -sf http://localhost:$TEST_PORT/health > /dev/null 2>&1; then
            echo "‚úÖ Container is ready after ${i} seconds"
            READY=true
            break
          fi
          if [ $((i % 15)) -eq 0 ]; then
            echo "‚ö†Ô∏è Still waiting... (${i}s elapsed)"
            docker logs --tail=10 test-blacklist-container || true
          fi
          sleep 1
        done
        
        if [ "$READY" = false ]; then
          echo "‚ùå Container failed to become ready within 90 seconds"
          echo ""
          echo "üîç Container logs:"
          docker logs test-blacklist-container || true
          echo ""
          echo "üîç Network information:"
          docker network inspect test-blacklist-network || true
          exit 1
        fi
        
        # Comprehensive health check
        echo "üîç Running comprehensive health checks..."
        
        # Basic health endpoint
        echo "Testing basic health endpoint..."
        if ! curl -f http://localhost:$TEST_PORT/health; then
          echo ""
          echo "‚ùå Basic health check failed"
          echo "üîç Container logs:"
          docker logs test-blacklist-container
          exit 1
        fi
        
        # Test detailed health endpoint (if available)
        echo ""
        echo "Testing detailed health endpoint..."
        curl -f http://localhost:$TEST_PORT/api/health 2>/dev/null || echo "‚ÑπÔ∏è Detailed health endpoint not available"
        
        # Test readiness endpoint
        echo ""
        echo "Testing readiness endpoint..."
        curl -f http://localhost:$TEST_PORT/ready 2>/dev/null || echo "‚ÑπÔ∏è Readiness endpoint not available"
        
        echo ""
        echo "‚úÖ All health checks passed successfully"
        
        # Cleanup
        echo ""
        echo "üßπ Cleaning up test containers..."
        docker stop test-blacklist-container || true
        docker stop test-redis-container || true
        docker stop test-postgres-container || true
        docker rm test-redis-container || true
        docker rm test-postgres-container || true
        docker network rm test-blacklist-network || true
        
        echo "‚úÖ Health test completed successfully"

    - name: Create GitHub Release
      if: env.VERSION != ''
      continue-on-error: true
      run: |
        echo "üéØ Attempting to create GitHub Release v${{ env.VERSION }}"
        
        # Try to create release using GitHub CLI - continue if it fails
        if gh release create "v${{ env.VERSION }}" \
          --title "Release v${{ env.VERSION }}" \
          --notes "üöÄ **Blacklist Management System v${{ env.VERSION }}**

        **üì¶ Docker Images:**
        - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }}\`
        - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\`
        - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}\`

        **üîç Changes:**
        Automated release with comprehensive version management and fixed Docker build pipeline.

        **üìä Deployment:**
        - Live System: https://blacklist.jclee.me/
        - Health Check: https://blacklist.jclee.me/health
        - Documentation: https://jclee94.github.io/blacklist/

        **üîß Installation:**
        \`\`\`bash
        docker-compose pull && docker-compose up -d
        \`\`\`

        **üõ†Ô∏è Fixed Issues:**
        - Updated GitHub Actions workflow to use modern release creation
        - Optimized Docker build pipeline
        - Fixed application entry point paths
        - Enhanced error handling and logging" \
          --latest 2>/dev/null; then
          echo "‚úÖ GitHub Release v${{ env.VERSION }} created successfully"
        else
          echo "‚ö†Ô∏è GitHub Release creation failed - continuing deployment (this is non-critical)"
          echo "üìù Manual release can be created later with tag v${{ env.VERSION }}"
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Cleanup old images
      run: |
        docker image prune -f
        docker images | grep ${{ env.IMAGE_NAME }} | grep -v latest | head -n -3 | awk '{print $3}' | xargs -r docker rmi || true

    - name: Logout from registry
      if: always()
      run: docker logout ${{ env.REGISTRY }}

    - name: Final deployment summary
      run: |
        echo "üéâ CI/CD PIPELINE ÏôÑÎ£å - v${{ env.VERSION }}"
        echo "========================================================================================"
        echo ""
        echo "üì¶ ÎπåÎìúÎêú Ïù¥ÎØ∏ÏßÄÎì§:"
        echo "   ‚úÖ ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
        echo "   ‚úÖ ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ env.VERSION }}"
        echo "   ‚úÖ ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
        
        # Check if support images were built
        if docker images | grep -q "${{ env.REDIS_IMAGE_NAME }}"; then
          echo "   ‚úÖ ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:latest"
        fi
        
        if docker images | grep -q "${{ env.POSTGRESQL_IMAGE_NAME }}"; then
          echo "   ‚úÖ ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:latest"
        fi
        
        echo ""
        echo "üöÄ Î∞∞Ìè¨ ÏòµÏÖò:"
        echo "   üîÑ Watchtower ÏûêÎèô ÏóÖÎç∞Ïù¥Ìä∏: 1ÏãúÍ∞Ñ ÎÇ¥"
        echo "   ‚ö° Ï¶âÏãú ÏàòÎèô Î∞∞Ìè¨: docker-compose pull && docker-compose up -d"
        echo ""
        echo "üîç Î™®ÎãàÌÑ∞ÎßÅ Î™ÖÎ†πÏñ¥:"
        echo "   üìä ÏÉÅÌÉú ÌôïÏù∏: docker-compose ps"
        echo "   üè• Ìó¨Ïä§Ï≤¥ÌÅ¨: curl http://localhost:32542/health"
        echo "   üìú Î°úÍ∑∏ ÌôïÏù∏: docker-compose logs -f blacklist"
        echo ""
        echo "üåê ÏÑúÎπÑÏä§ ÏóîÎìúÌè¨Ïù∏Ìä∏:"
        echo "   üè† Local: http://localhost:32542"
        echo "   üåç Production: https://blacklist.jclee.me"
        echo "   üìñ Portfolio: https://jclee94.github.io/blacklist"
        echo ""
        echo "üéØ Î¶¥Î¶¨Ïä§ Ï†ïÎ≥¥:"
        echo "   üìã Release Notes: https://github.com/${{ github.repository }}/releases/tag/v${{ env.VERSION }}"
        echo "   üì¶ Registry: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
        echo "   üîñ Version: v${{ env.VERSION }}"
        echo "   üìÖ Build Time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
        echo ""
        echo "‚úÖ CI/CD ÌååÏù¥ÌîÑÎùºÏù∏Ïù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏôÑÎ£åÎêòÏóàÏäµÎãàÎã§!"
        echo "========================================================================================"

    - name: Run post-deployment verification
      run: |
        echo "üîç Running post-deployment verification..."
        
        # Make verification script executable
        chmod +x scripts/post-deploy-verification.sh
        
        # Run verification with timeout
        if timeout 300 bash scripts/post-deploy-verification.sh; then
          echo "‚úÖ Post-deployment verification passed"
        else
          echo "‚ùå Post-deployment verification failed or timed out"
          echo "‚ÑπÔ∏è This may be normal if services need more time to start"
          # Don't fail the entire workflow for verification issues
        fi