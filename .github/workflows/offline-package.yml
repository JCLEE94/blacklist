name: Build Offline Package

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version for the offline package'
        required: true
        default: 'v2.0.1'

# Prevent concurrent offline package builds
concurrency:
  group: offline-package-build
  cancel-in-progress: false

jobs:
  build-offline-package:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install wheel setuptools
        
    - name: Create offline package directory
      run: |
        mkdir -p offline-package
        mkdir -p offline-package/wheels
        mkdir -p offline-package/scripts
        mkdir -p offline-package/config
        mkdir -p offline-package/docs
        
    - name: Download Python wheels
      run: |
        pip download -r requirements.txt -d offline-package/wheels/
        
    - name: Copy application files
      run: |
        # Copy main application files
        cp -r src offline-package/
        cp -r templates offline-package/
        cp -r static offline-package/
        cp main.py offline-package/
        cp init_database.py offline-package/
        cp requirements.txt offline-package/
        cp README.md offline-package/
        cp offline_deployment_plan.md offline-package/docs/
        
        # Copy configuration files
        cp .env.example offline-package/config/
        cp docker-compose.yml offline-package/config/
        cp Dockerfile offline-package/config/
        
        # Copy start script if exists
        if [ -f start.sh ]; then
          cp start.sh offline-package/scripts/
        fi
        
    - name: Create start script
      run: |
        cat > offline-package/scripts/start.sh << 'EOF'
        #!/bin/bash
        
        # Blacklist Management System - Start Script
        # For offline/air-gapped Linux environments
        
        set -e
        
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        BASE_DIR="$(dirname "$SCRIPT_DIR")"
        
        # Colors for output
        RED='\033[0;31m'
        GREEN='\033[0;32m'
        YELLOW='\033[1;33m'
        NC='\033[0m' # No Color
        
        # Default values
        MODE="python"
        ACTION="start"
        
        # Parse arguments
        while [[ $# -gt 0 ]]; do
            case $1 in
                --docker)
                    MODE="docker"
                    shift
                    ;;
                start|stop|restart|status|logs)
                    ACTION="$1"
                    shift
                    ;;
                *)
                    echo "Unknown option: $1"
                    echo "Usage: $0 [--docker] [start|stop|restart|status|logs]"
                    exit 1
                    ;;
            esac
        done
        
        # Python mode functions
        python_start() {
            echo -e "${GREEN}Starting Blacklist service (Python mode)...${NC}"
            cd "$BASE_DIR"
            
            # Check if virtual environment exists
            if [ ! -d "venv" ]; then
                echo -e "${YELLOW}Virtual environment not found. Creating...${NC}"
                python3 -m venv venv
                source venv/bin/activate
                pip install --no-index --find-links=wheels -r requirements.txt
            else
                source venv/bin/activate
            fi
            
            # Check if database exists
            if [ ! -f "instance/blacklist.db" ]; then
                echo -e "${YELLOW}Database not found. Initializing...${NC}"
                python init_database.py
            fi
            
            # Start the application
            nohup python main.py > logs/blacklist.log 2>&1 &
            echo $! > blacklist.pid
            echo -e "${GREEN}Service started with PID: $(cat blacklist.pid)${NC}"
            echo "View logs: tail -f logs/blacklist.log"
        }
        
        python_stop() {
            echo -e "${YELLOW}Stopping Blacklist service...${NC}"
            if [ -f blacklist.pid ]; then
                PID=$(cat blacklist.pid)
                if ps -p $PID > /dev/null; then
                    kill $PID
                    rm blacklist.pid
                    echo -e "${GREEN}Service stopped${NC}"
                else
                    echo -e "${YELLOW}Service not running (stale PID file)${NC}"
                    rm blacklist.pid
                fi
            else
                echo -e "${YELLOW}Service not running (no PID file)${NC}"
            fi
        }
        
        python_status() {
            if [ -f blacklist.pid ]; then
                PID=$(cat blacklist.pid)
                if ps -p $PID > /dev/null; then
                    echo -e "${GREEN}Service is running (PID: $PID)${NC}"
                    # Health check
                    if curl -s http://localhost:8541/health > /dev/null 2>&1; then
                        echo -e "${GREEN}Health check: OK${NC}"
                    else
                        echo -e "${YELLOW}Health check: Service starting...${NC}"
                    fi
                else
                    echo -e "${RED}Service is not running (stale PID file)${NC}"
                fi
            else
                echo -e "${YELLOW}Service is not running${NC}"
            fi
        }
        
        python_logs() {
            if [ -f logs/blacklist.log ]; then
                tail -f logs/blacklist.log
            else
                echo -e "${YELLOW}No log file found${NC}"
            fi
        }
        
        # Docker mode functions
        docker_start() {
            echo -e "${GREEN}Starting Blacklist service (Docker mode)...${NC}"
            cd "$BASE_DIR"
            
            # Load Docker images if needed
            if ! docker images | grep -q "blacklist:offline"; then
                if [ -f images/blacklist.tar ]; then
                    echo -e "${YELLOW}Loading Docker images...${NC}"
                    docker load < images/blacklist.tar
                    docker load < images/redis.tar
                fi
            fi
            
            # Start with docker-compose
            docker-compose -f config/docker-compose.yml up -d
            echo -e "${GREEN}Service started${NC}"
        }
        
        docker_stop() {
            echo -e "${YELLOW}Stopping Blacklist service...${NC}"
            docker-compose -f config/docker-compose.yml down
            echo -e "${GREEN}Service stopped${NC}"
        }
        
        docker_status() {
            docker-compose -f config/docker-compose.yml ps
            # Health check
            if curl -s http://localhost:32542/health > /dev/null 2>&1; then
                echo -e "${GREEN}Health check: OK${NC}"
            else
                echo -e "${RED}Health check: Failed${NC}"
            fi
        }
        
        docker_logs() {
            docker-compose -f config/docker-compose.yml logs -f
        }
        
        # Create necessary directories
        mkdir -p "$BASE_DIR/logs" "$BASE_DIR/instance" "$BASE_DIR/data"
        
        # Execute action based on mode
        if [ "$MODE" = "docker" ]; then
            case $ACTION in
                start)   docker_start ;;
                stop)    docker_stop ;;
                restart) docker_stop && docker_start ;;
                status)  docker_status ;;
                logs)    docker_logs ;;
            esac
        else
            case $ACTION in
                start)   python_start ;;
                stop)    python_stop ;;
                restart) python_stop && python_start ;;
                status)  python_status ;;
                logs)    python_logs ;;
            esac
        fi
        EOF
        chmod +x offline-package/scripts/start.sh
        
    - name: Create installation script
      run: |
        cat > offline-package/scripts/install.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "==================================="
        echo "Blacklist Offline Package Installer"
        echo "==================================="
        
        # Check Python version
        if ! command -v python3 &> /dev/null; then
            echo "Error: Python 3 is not installed"
            exit 1
        fi
        
        PYTHON_VERSION=$(python3 -c 'import sys; print(".".join(map(str, sys.version_info[:2])))')
        echo "Python version: $PYTHON_VERSION"
        
        # Create virtual environment
        echo "Creating virtual environment..."
        python3 -m venv venv
        source venv/bin/activate
        
        # Upgrade pip
        pip install --upgrade pip
        
        # Install from local wheels
        echo "Installing dependencies from offline wheels..."
        pip install --no-index --find-links=../wheels -r ../requirements.txt
        
        # Setup configuration
        echo "Setting up configuration..."
        if [ ! -f ../.env ]; then
            cp ../config/.env.example ../.env
            echo "Created .env file - please edit with your settings"
        fi
        
        # Initialize database
        echo "Initializing database..."
        cd ..
        python3 init_database.py
        
        echo "==================================="
        echo "Installation complete!"
        echo "To start the application:"
        echo "  source venv/bin/activate"
        echo "  python main.py"
        echo "==================================="
        EOF
        chmod +x offline-package/scripts/install.sh
        
    - name: Create Docker load script
      run: |
        cat > offline-package/scripts/docker-load.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "Loading Docker images..."
        
        if [ -f ../images/blacklist.tar ]; then
            docker load < ../images/blacklist.tar
            echo "Loaded blacklist image"
        fi
        
        if [ -f ../images/redis.tar ]; then
            docker load < ../images/redis.tar
            echo "Loaded Redis image"
        fi
        
        echo "Docker images loaded successfully"
        docker images | grep -E "blacklist|redis"
        EOF
        chmod +x offline-package/scripts/docker-load.sh
        
    - name: Build Docker images and save
      run: |
        mkdir -p offline-package/images
        
        # Build application image
        docker build -t blacklist:offline .
        docker save blacklist:offline > offline-package/images/blacklist.tar
        
        # Pull and save Redis image
        docker pull redis:7-alpine
        docker save redis:7-alpine > offline-package/images/redis.tar
        
    - name: Create README
      run: |
        cat > offline-package/README_OFFLINE.md << 'EOF'
        # Blacklist Offline Package
        
        This package contains everything needed to deploy the Blacklist Management System
        in an air-gapped environment without internet access.
        
        ## Contents
        
        - `wheels/` - Python dependency packages
        - `images/` - Docker images (blacklist, redis)
        - `scripts/` - Installation and setup scripts
        - `config/` - Configuration templates
        - `docs/` - Documentation
        - `src/` - Application source code
        
        ## Installation Methods
        
        ### Method 1: Python Installation
        
        1. Navigate to scripts directory:
           ```bash
           cd scripts
           ```
        
        2. Run the installation script:
           ```bash
           ./install.sh
           ```
        
        3. Edit configuration:
           ```bash
           nano .env
           ```
        
        4. Start the application:
           ```bash
           source venv/bin/activate
           python main.py
           ```
        
        ### Method 2: Docker Installation
        
        1. Load Docker images:
           ```bash
           cd scripts
           ./docker-load.sh
           ```
        
        2. Start with docker-compose:
           ```bash
           cd ..
           docker-compose -f config/docker-compose.yml up -d
           ```
        
        ## Configuration
        
        Edit `.env` file with your settings:
        - Database configuration
        - Redis configuration
        - Security keys
        - External API credentials (if needed)
        
        ## Verification
        
        Check service health:
        ```bash
        curl http://localhost:32542/health
        ```
        
        ## Support
        
        For issues, refer to `docs/offline_deployment_plan.md`
        EOF
        
    - name: Create tarball
      run: |
        VERSION=${{ github.event.inputs.version || github.ref_name }}
        tar -czf blacklist-offline-package-${VERSION}.tar.gz offline-package/
        echo "Created offline package: blacklist-offline-package-${VERSION}.tar.gz"
        ls -lh blacklist-offline-package-*.tar.gz
        
    - name: Upload artifact
      uses: actions/upload-artifact@v3
      with:
        name: offline-package
        path: blacklist-offline-package-*.tar.gz
        
    - name: Create Release (if tag)
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        files: blacklist-offline-package-*.tar.gz
        body: |
          ## Offline Package Release
          
          This release includes an offline deployment package for air-gapped environments.
          
          ### Package Contents:
          - All Python dependencies as wheel files
          - Docker images (blacklist application + Redis)
          - Installation scripts
          - Configuration templates
          - Complete documentation
          
          ### Installation:
          1. Transfer the `.tar.gz` file to your air-gapped environment
          2. Extract: `tar -xzf blacklist-offline-package-*.tar.gz`
          3. Follow instructions in `offline-package/README_OFFLINE.md`
          
          ### Requirements:
          - Linux/Unix environment
          - Python 3.8+ OR Docker 20.10+
          - 2GB free disk space
          - 1GB RAM minimum
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}