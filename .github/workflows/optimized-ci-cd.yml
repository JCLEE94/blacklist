name: Optimized CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options: [development, staging, production]
        default: 'development'
      skip_tests:
        description: 'Skip test execution'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: registry.jclee.me
  IMAGE_NAME: blacklist
  DOCKER_BUILDKIT: 1
  BUILDX_CACHE_MODE: max
  # Performance optimizations
  PYTHONUNBUFFERED: 1
  PYTHONDONTWRITEBYTECODE: 1

# Concurrency management - cancel in-progress runs for PRs
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: ${{ github.event_name == 'pull_request' }}

jobs:
  # Stage 1: Setup and Validation
  setup:
    name: üîß Setup & Validation
    runs-on: self-hosted
    timeout-minutes: 5
    outputs:
      version: ${{ steps.version.outputs.version }}
      should_deploy: ${{ steps.deploy-check.outputs.should_deploy }}
      environment: ${{ steps.env-check.outputs.environment }}
      cache-key: ${{ steps.cache-key.outputs.key }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for version management

      - name: Generate cache key
        id: cache-key
        run: |
          CACHE_KEY="${{ runner.os }}-buildx-${{ hashFiles('config/requirements.txt', 'docker/Dockerfile') }}"
          echo "key=$CACHE_KEY" >> $GITHUB_OUTPUT
          echo "Generated cache key: $CACHE_KEY"

      - name: Validate version consistency
        run: |
          if [ -f scripts/version-manager.py ]; then
            python3 scripts/version-manager.py --validate-only --project-root .
          else
            echo "‚ö†Ô∏è Version manager not found - using fallback"
          fi

      - name: Get version
        id: version
        run: |
          VERSION=$(cat version.txt 2>/dev/null || echo "1.0.0")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "üìç Version: $VERSION"

      - name: Environment check
        id: env-check
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENV="production"
          elif [ "${{ github.ref }}" == "refs/heads/develop" ]; then
            ENV="staging"
          else
            ENV="development"
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "üéØ Target environment: $ENV"

      - name: Deployment check
        id: deploy-check
        run: |
          SHOULD_DEPLOY="false"
          if [ "${{ github.ref }}" == "refs/heads/main" ] || [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            SHOULD_DEPLOY="true"
          fi
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "üöÄ Should deploy: $SHOULD_DEPLOY"

  # Stage 2: Code Quality & Security (Parallel)
  code-quality:
    name: üîç Code Quality
    runs-on: self-hosted
    timeout-minutes: 10
    needs: setup
    if: github.event.inputs.skip_tests != 'true'
    strategy:
      fail-fast: false
      matrix:
        check: [lint, security, format]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python with caching
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: 'config/requirements*.txt'

      - name: Install dependencies (cached)
        run: |
          pip install --upgrade pip
          pip install -r config/requirements.txt
          pip install -r config/requirements-dev.txt 2>/dev/null || echo "No dev requirements"

      - name: Run linting
        if: matrix.check == 'lint'
        run: |
          echo "üîç Running linting checks..."
          flake8 src/ app/ --count --select=E9,F63,F7,F82 --show-source --statistics
          flake8 src/ app/ --max-line-length=88 --extend-ignore=E203,W503 --exit-zero

      - name: Run security checks
        if: matrix.check == 'security'
        run: |
          echo "üîí Running security analysis..."
          bandit -r src/ app/ -ll -f json -o bandit-report.json || true
          safety check --json --output safety-report.json || true

      - name: Check code formatting
        if: matrix.check == 'format'
        run: |
          echo "üé® Checking code formatting..."
          black --check src/ app/ tests/ || echo "Format issues found"
          isort --check-only src/ app/ tests/ || echo "Import order issues found"

      - name: Upload security reports
        if: matrix.check == 'security'
        uses: actions/upload-artifact@v3
        with:
          name: security-reports
          path: |
            bandit-report.json
            safety-report.json
          retention-days: 30

  # Stage 3: Testing Matrix (Parallel)
  test-matrix:
    name: üß™ Tests
    runs-on: self-hosted
    timeout-minutes: 15
    needs: setup
    if: github.event.inputs.skip_tests != 'true'
    strategy:
      fail-fast: false
      matrix:
        test-type: [unit, integration, api, collection]
        python-version: ['3.9', '3.11']
        exclude:
          # Run integration tests only on Python 3.11
          - test-type: integration
            python-version: '3.9'
          - test-type: collection
            python-version: '3.9'
    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python ${{ matrix.python-version }}
        uses: actions/setup-python@v4
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'
          cache-dependency-path: 'config/requirements*.txt'

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r config/requirements.txt
          pip install pytest pytest-cov pytest-xdist pytest-timeout

      - name: Run ${{ matrix.test-type }} tests
        run: |
          case "${{ matrix.test-type }}" in
            "unit")
              pytest -m unit -v --cov=src --cov-report=xml --timeout=300 -x
              ;;
            "integration")
              pytest -m integration -v --timeout=600 -x
              ;;
            "api")
              pytest -m api -v --timeout=300 -x
              ;;
            "collection")
              pytest -m collection -v --timeout=900 -x
              ;;
          esac

      - name: Upload coverage reports
        if: matrix.test-type == 'unit' && matrix.python-version == '3.11'
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          flags: unittests
          name: codecov-umbrella

  # Stage 4: Build (Optimized with Advanced Caching)
  build:
    name: üê≥ Build Images
    runs-on: self-hosted
    timeout-minutes: 20
    needs: [setup, code-quality, test-matrix]
    if: always() && needs.setup.result == 'success' && (needs.code-quality.result == 'success' || needs.code-quality.result == 'skipped') && (needs.test-matrix.result == 'success' || needs.test-matrix.result == 'skipped')
    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-metadata: ${{ steps.build.outputs.metadata }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx (Enhanced)
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container
          driver-opts: |
            network=host
            image=moby/buildkit:v0.12.0
          buildkitd-flags: |
            --allow-insecure-entitlement=network.host
            --allow-insecure-entitlement=security.insecure

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.REGISTRY_USERNAME }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=v${{ needs.setup.outputs.version }}

      - name: Advanced Build Cache Setup
        uses: actions/cache@v3
        with:
          path: |
            /tmp/.buildx-cache
            ~/.docker/buildx
          key: ${{ needs.setup.outputs.cache-key }}-${{ matrix.platform }}
          restore-keys: |
            ${{ needs.setup.outputs.cache-key }}-
            ${{ runner.os }}-buildx-

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/Dockerfile
          platforms: ${{ matrix.platform }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=local,src=/tmp/.buildx-cache
            type=gha
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: |
            type=local,dest=/tmp/.buildx-cache-new,mode=${{ env.BUILDX_CACHE_MODE }}
            type=gha,mode=${{ env.BUILDX_CACHE_MODE }}
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=${{ env.BUILDX_CACHE_MODE }}
          build-args: |
            VERSION=${{ needs.setup.outputs.version }}
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VCS_REF=${{ github.sha }}
            PYTHON_VERSION=3.11
          provenance: true
          sbom: true

      - name: Move cache (Performance optimization)
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache 2>/dev/null || true

  # Stage 5: Security Scanning (Parallel)
  security-scan:
    name: üîí Security Scan
    runs-on: self-hosted
    timeout-minutes: 10
    needs: [setup, build]
    if: needs.build.result == 'success'
    strategy:
      matrix:
        scanner: [trivy, grype]
    steps:
      - name: Run Trivy vulnerability scanner
        if: matrix.scanner == 'trivy'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ needs.setup.outputs.version }}'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Run Grype vulnerability scanner
        if: matrix.scanner == 'grype'
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
          grype ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ needs.setup.outputs.version }} -o sarif > grype-results.sarif

      - name: Upload SARIF results
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: '${{ matrix.scanner }}-results.sarif'
          category: ${{ matrix.scanner }}

  # Stage 6: Integration Testing
  integration-test:
    name: üß™ Integration Tests
    runs-on: self-hosted
    timeout-minutes: 15
    needs: [setup, build]
    if: needs.build.result == 'success'
    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
      postgres:
        image: postgres:15-alpine
        ports:
          - 5432:5432
        env:
          POSTGRES_DB: blacklist_test
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_pass
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Test image health
        run: |
          echo "üè• Testing application image health..."
          
          TEST_PORT=45678
          CONTAINER_NAME="test-blacklist-${{ github.run_id }}"
          
          # Cleanup
          docker rm -f $CONTAINER_NAME || true
          
          # Run container with test configuration
          docker run --rm --name $CONTAINER_NAME -d \
            -p $TEST_PORT:2542 \
            -e DATABASE_URL="postgresql://test_user:test_pass@localhost:5432/blacklist_test" \
            -e REDIS_URL="redis://localhost:6379/1" \
            -e FLASK_ENV=production \
            -e COLLECTION_ENABLED=false \
            -e FORCE_DISABLE_COLLECTION=true \
            -e SECRET_KEY=test-secret-key \
            -e JWT_SECRET_KEY=test-jwt-secret \
            --network host \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ needs.setup.outputs.version }}
          
          # Wait for container and test health
          sleep 30
          
          for i in {1..30}; do
            if curl -sf http://localhost:$TEST_PORT/health > /dev/null; then
              echo "‚úÖ Container is ready after ${i} attempts"
              break
            fi
            sleep 2
          done
          
          # Health checks
          curl -f http://localhost:$TEST_PORT/health | jq '.'
          curl -f http://localhost:$TEST_PORT/ready || echo "Ready endpoint not available"
          
          # Cleanup
          docker stop $CONTAINER_NAME || true

  # Stage 7: Deployment (Conditional)
  deploy:
    name: üöÄ Deploy
    runs-on: self-hosted
    timeout-minutes: 10
    needs: [setup, build, integration-test]
    if: needs.setup.outputs.should_deploy == 'true' && needs.build.result == 'success' && needs.integration-test.result == 'success'
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to ${{ needs.setup.outputs.environment }}
        run: |
          echo "üöÄ Deploying to ${{ needs.setup.outputs.environment }}..."
          
          case "${{ needs.setup.outputs.environment }}" in
            "production")
              echo "üåü Production deployment"
              # Production deployment logic
              docker-compose pull
              docker-compose up -d
              ;;
            "staging")
              echo "üß™ Staging deployment"
              # Staging deployment logic
              kubectl set image deployment/blacklist-staging blacklist=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ needs.setup.outputs.version }} -n staging
              ;;
            "development")
              echo "üîß Development deployment"
              # Development deployment logic
              kubectl set image deployment/blacklist-dev blacklist=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ needs.setup.outputs.version }} -n development
              ;;
          esac

      - name: Run deployment verification
        run: |
          echo "üîç Running comprehensive deployment verification..."
          
          # Install required dependencies
          pip install requests urllib3
          
          # Determine target URL based on environment
          case "${{ needs.setup.outputs.environment }}" in
            "production")
              TARGET_URL="https://blacklist.jclee.me"
              ;;
            "staging")
              TARGET_URL="https://staging.blacklist.jclee.me"
              ;;
            "development")
              TARGET_URL="https://dev.blacklist.jclee.me"
              ;;
            *)
              TARGET_URL="https://blacklist.jclee.me"
              ;;
          esac
          
          echo "üéØ Target URL: $TARGET_URL"
          
          # Run comprehensive verification
          if python3 scripts/deployment-verification.py \
              --url "$TARGET_URL" \
              --timeout 300 \
              --wait \
              --output "deployment-verification-report.md"; then
            echo "‚úÖ Deployment verification passed successfully"
            
            # Show verification summary
            echo ""
            echo "üìä Verification Summary:"
            echo "======================="
            grep -A 15 "## üìä Summary" deployment-verification-report.md || echo "Summary not found"
            
          else
            echo "‚ùå Deployment verification failed"
            echo "üîç Check deployment-verification-report.md for details"
            
            # Upload report for debugging
            if [ -f "deployment-verification-report.md" ]; then
              cat deployment-verification-report.md
            fi
            
            exit 1
          fi
          
      - name: Upload verification reports
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: verification-reports-${{ needs.setup.outputs.environment }}-${{ github.run_id }}
          path: |
            deployment-verification-report.md
            version-verification.json
            health-verification.json
          retention-days: 30

      - name: Update GitHub deployment status
        uses: bobheadxi/deployments@v1
        with:
          step: finish
          token: ${{ secrets.GITHUB_TOKEN }}
          status: ${{ job.status }}
          deployment_id: ${{ steps.deployment.outputs.deployment_id }}
          env_url: ${{ needs.setup.outputs.environment == 'production' && 'https://blacklist.jclee.me' || '' }}

  # Stage 8: Post-deployment
  post-deploy:
    name: üìä Post-deployment
    runs-on: self-hosted
    timeout-minutes: 5
    needs: [setup, deploy]
    if: needs.deploy.result == 'success'
    steps:
      - name: Create GitHub Release
        if: needs.setup.outputs.environment == 'production'
        uses: ncipollo/create-release@v1
        with:
          tag: v${{ needs.setup.outputs.version }}
          name: Release v${{ needs.setup.outputs.version }}
          body: |
            üöÄ **Blacklist Management System v${{ needs.setup.outputs.version }}**
            
            **üì¶ Docker Images:**
            - `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ needs.setup.outputs.version }}`
            - `${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest`
            
            **üîó Deployment:**
            - Live System: https://blacklist.jclee.me/
            - Health Check: https://blacklist.jclee.me/health
            - Portfolio: https://jclee94.github.io/blacklist/
            
            **üèóÔ∏è Built with:**
            - Multi-platform support (linux/amd64, linux/arm64)
            - Advanced caching strategies
            - Comprehensive security scanning
            - SBOM and provenance attestation
          token: ${{ secrets.GITHUB_TOKEN }}
          makeLatest: true

      - name: Update portfolio
        if: needs.setup.outputs.environment == 'production'
        run: |
          echo "üìÑ Updating portfolio..."
          if [ -f scripts/generate-portfolio.sh ]; then
            chmod +x scripts/generate-portfolio.sh
            ./scripts/generate-portfolio.sh
          fi

      - name: Cleanup old images
        run: |
          echo "üßπ Cleaning up old images..."
          docker image prune -f --filter "until=48h"
          
          # Keep only last 5 versions
          docker images ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} --format "table {{.Tag}}\t{{.CreatedAt}}" | \
            grep -E '^v[0-9]+\.[0-9]+\.[0-9]+' | \
            tail -n +6 | \
            awk '{print $1}' | \
            xargs -r -I {} docker rmi ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:{} || true

      - name: Performance metrics collection
        run: |
          echo "üìä Collecting performance metrics..."
          
          # Response time test
          if [ "${{ needs.setup.outputs.environment }}" == "production" ]; then
            RESPONSE_TIME=$(curl -w "%{time_total}" -s -o /dev/null https://blacklist.jclee.me/health)
            echo "Response time: ${RESPONSE_TIME}s"
            
            if (( $(echo "$RESPONSE_TIME > 1.0" | bc -l) )); then
              echo "‚ö†Ô∏è Warning: Response time exceeded 1 second"
            else
              echo "‚úÖ Response time within acceptable limits"
            fi
          fi

      - name: Deployment summary
        run: |
          echo "üéâ DEPLOYMENT SUMMARY"
          echo "===================="
          echo "üè∑Ô∏è  Version: v${{ needs.setup.outputs.version }}"
          echo "üéØ Environment: ${{ needs.setup.outputs.environment }}"
          echo "üê≥ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ needs.setup.outputs.version }}"
          echo "‚è∞ Deployed: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "üìä Build Duration: ${{ github.event.head_commit.timestamp && 'Available after completion' || 'N/A' }}"
          echo ""
          echo "üîó Links:"
          echo "  üìñ Portfolio: https://jclee94.github.io/blacklist/"
          echo "  üåê Live System: https://blacklist.jclee.me/"
          echo "  üìã Registry: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          echo ""
          echo "‚úÖ Deployment completed successfully!"