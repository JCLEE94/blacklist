# DISABLED - Superseded by main-deploy.yml
# This workflow is disabled to reduce runner conflicts
name: Optimized CI/CD Pipeline (DISABLED)

on:
  # All triggers disabled - use main-deploy.yml instead
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild without cache'
        required: false
        default: false
        type: boolean
      run_security_scan:
        description: 'Run extended security scan'
        required: false
        default: true
        type: boolean

env:
  REGISTRY: registry.jclee.me
  IMAGE_NAME: blacklist
  REDIS_IMAGE_NAME: blacklist-redis
  POSTGRESQL_IMAGE_NAME: blacklist-postgresql
  DOCKER_BUILDKIT: 1
  BUILDX_NO_DEFAULT_ATTESTATIONS: 1

# Optimized concurrency for self-hosted runners
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # Preparation job for cache optimization
  prepare:
    name: ðŸ”§ Prepare Environment
    runs-on: self-hosted
    outputs:
      version: ${{ steps.version.outputs.version }}
      cache-key: ${{ steps.cache-key.outputs.key }}
      has-changes: ${{ steps.changes.outputs.has-changes }}
    steps:
      - name: Cleanup workspace
        run: |
          echo "ðŸ§¹ Cleaning up workspace..."
          sudo rm -rf ${{ github.workspace }}/* || true
          sudo rm -rf ${{ github.workspace }}/.* 2>/dev/null || true
          docker system prune -f --volumes || true

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Get version and cache key
        id: version
        run: |
          VERSION=$(cat version.txt 2>/dev/null || echo "1.0.0")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ðŸ“ Version: $VERSION"

      - name: Generate cache key
        id: cache-key
        run: |
          CACHE_KEY="buildx-${{ runner.os }}-${{ hashFiles('config/requirements.txt', 'docker/Dockerfile', 'build/docker/Dockerfile') }}"
          echo "key=$CACHE_KEY" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Cache key: $CACHE_KEY"

      - name: Check for significant changes
        id: changes
        run: |
          if [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "ðŸ”„ Main branch push - full build required"
          elif git diff --name-only HEAD~1 | grep -E '\.(py|txt|yml|yaml|json|sh|Dockerfile)$' > /dev/null; then
            echo "has-changes=true" >> $GITHUB_OUTPUT
            echo "ðŸ”„ Code changes detected"
          else
            echo "has-changes=false" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ No significant changes detected"
          fi

  # Security scanning job
  security-scan:
    name: ðŸ”’ Security Scan
    runs-on: self-hosted
    needs: prepare
    if: needs.prepare.outputs.has-changes == 'true' || github.event.inputs.run_security_scan == 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          cache: 'pip'

      - name: Install security tools
        run: |
          python -m pip install --upgrade pip
          pip install bandit safety semgrep

      - name: Run Bandit security scan
        run: |
          echo "ðŸ” Running Bandit security scan..."
          bandit -r src/ -f json -o bandit-report.json || true
          bandit -r src/ -ll --exclude src/test*

      - name: Run Safety check
        run: |
          echo "ðŸ” Checking for vulnerable dependencies..."
          safety check --json --output safety-report.json || true
          safety check

      - name: Run Semgrep scan
        if: github.event.inputs.run_security_scan == 'true'
        run: |
          echo "ðŸ” Running Semgrep security patterns..."
          semgrep --config=auto src/ --json --output=semgrep-report.json || true
          semgrep --config=auto src/ --error

      - name: Upload security reports
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: security-reports
          path: |
            bandit-report.json
            safety-report.json
            semgrep-report.json
          retention-days: 30

  # Testing job with matrix strategy
  test:
    name: ðŸ§ª Test Suite
    runs-on: self-hosted
    needs: prepare
    if: needs.prepare.outputs.has-changes == 'true'
    strategy:
      matrix:
        test-type: [unit, integration, api]
      fail-fast: false
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          cache: 'pip'

      - name: Cache test dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/pip
            .pytest_cache
          key: test-${{ runner.os }}-${{ hashFiles('config/requirements.txt') }}
          restore-keys: |
            test-${{ runner.os }}-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r config/requirements.txt
          pip install pytest pytest-cov pytest-xdist

      - name: Run ${{ matrix.test-type }} tests
        run: |
          echo "ðŸ§ª Running ${{ matrix.test-type }} tests..."
          case "${{ matrix.test-type }}" in
            unit)
              pytest -m unit --cov=src --cov-report=xml --junitxml=junit-unit.xml -v
              ;;
            integration)
              pytest -m integration --junitxml=junit-integration.xml -v
              ;;
            api)
              pytest -m api --junitxml=junit-api.xml -v
              ;;
          esac

      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results-${{ matrix.test-type }}
          path: |
            junit-*.xml
            coverage.xml
          retention-days: 30

  # Optimized build job with advanced caching
  build:
    name: ðŸ³ Build Images
    runs-on: self-hosted
    needs: [prepare, security-scan, test]
    if: always() && (needs.prepare.outputs.has-changes == 'true' || github.event.inputs.force_rebuild == 'true')
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            network=host
            image=moby/buildkit:master
          buildkitd-flags: |
            --allow-insecure-entitlement network.host
            --allow-insecure-entitlement security.insecure

      - name: Configure advanced cache
        uses: actions/cache@v3
        with:
          path: |
            /tmp/.buildx-cache
            /tmp/.buildx-cache-redis
            /tmp/.buildx-cache-postgres
            ~/.docker/buildx
          key: ${{ needs.prepare.outputs.cache-key }}-${{ github.sha }}
          restore-keys: |
            ${{ needs.prepare.outputs.cache-key }}-
            buildx-${{ runner.os }}-

      - name: Login to Container Registry
        run: |
          echo "ðŸ” Logging into registry..."
          echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ${{ env.REGISTRY }} \
            -u ${{ secrets.REGISTRY_USERNAME }} --password-stdin

      - name: Build and cache base images
        run: |
          echo "ðŸ”¨ Building support images with advanced caching..."
          
          # Build Redis with cache mount and multi-stage optimization
          if [ -f docker/redis/Dockerfile ]; then
            docker buildx build \
              --platform linux/amd64 \
              --cache-from type=local,src=/tmp/.buildx-cache-redis \
              --cache-to type=local,dest=/tmp/.buildx-cache-redis-new,mode=max \
              --cache-from type=registry,ref=${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:cache \
              --cache-to type=registry,ref=${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:cache,mode=max \
              -f docker/redis/Dockerfile \
              -t ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:latest \
              -t ${{ env.REGISTRY }}/${{ env.REDIS_IMAGE_NAME }}:${{ github.sha }} \
              --build-arg BUILDKIT_INLINE_CACHE=1 \
              --push \
              docker/redis/
          fi
          
          # Build PostgreSQL with optimization
          if [ -f docker/postgresql/Dockerfile ]; then
            docker buildx build \
              --platform linux/amd64 \
              --cache-from type=local,src=/tmp/.buildx-cache-postgres \
              --cache-to type=local,dest=/tmp/.buildx-cache-postgres-new,mode=max \
              --cache-from type=registry,ref=${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:cache \
              --cache-to type=registry,ref=${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:cache,mode=max \
              -f docker/postgresql/Dockerfile \
              -t ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:latest \
              -t ${{ env.REGISTRY }}/${{ env.POSTGRESQL_IMAGE_NAME }}:${{ github.sha }} \
              --build-arg BUILDKIT_INLINE_CACHE=1 \
              --push \
              docker/postgresql/
          fi

      - name: Build main application
        id: build
        run: |
          echo "ðŸš€ Building main application with advanced optimization..."
          
          # Use registry cache and local cache together for maximum efficiency
          docker buildx build \
            --platform linux/amd64 \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
            --cache-from type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache \
            --cache-to type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache,mode=max \
            -f build/docker/Dockerfile \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ needs.prepare.outputs.version }} \
            --build-arg VERSION=${{ needs.prepare.outputs.version }} \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=${{ github.sha }} \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            --metadata-file /tmp/metadata.json \
            --push \
            .
          
          # Extract image digest for security attestation
          DIGEST=$(jq -r '.containerimage.digest' /tmp/metadata.json 2>/dev/null || echo "")
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Image digest: $DIGEST"

      - name: Optimize cache storage
        run: |
          echo "ðŸ—‚ï¸ Optimizing cache storage..."
          
          # Move caches efficiently
          rm -rf /tmp/.buildx-cache && mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true
          rm -rf /tmp/.buildx-cache-redis && mv /tmp/.buildx-cache-redis-new /tmp/.buildx-cache-redis || true
          rm -rf /tmp/.buildx-cache-postgres && mv /tmp/.buildx-cache-postgres-new /tmp/.buildx-cache-postgres || true
          
          # Cleanup old cache layers (keep last 7 days)
          find /tmp/.buildx-cache* -type f -mtime +7 -delete 2>/dev/null || true

      - name: Run Trivy security scan on image
        run: |
          echo "ðŸ” Scanning built image with Trivy..."
          
          # Install Trivy if not available
          if ! command -v trivy &> /dev/null; then
            curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
          fi
          
          # Scan the built image
          trivy image \
            --format json \
            --output trivy-report.json \
            --severity HIGH,CRITICAL \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          
          # Show summary
          trivy image \
            --severity HIGH,CRITICAL \
            --no-progress \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      - name: Upload vulnerability report
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: trivy-report
          path: trivy-report.json
          retention-days: 30

  # Deployment verification job
  verify-deployment:
    name: âœ… Verify Deployment
    runs-on: self-hosted
    needs: [prepare, build]
    if: always() && needs.build.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Test image functionality
        run: |
          echo "ðŸ§ª Testing built image functionality..."
          
          # Create isolated test environment
          TEST_NETWORK="test-blacklist-${{ github.run_id }}"
          TEST_PORT=4$(shuf -i 0-9 -n 1)$(shuf -i 0-9 -n 1)$(shuf -i 0-9 -n 1)$(shuf -i 0-9 -n 1)
          
          # Cleanup any existing test containers
          docker network rm $TEST_NETWORK 2>/dev/null || true
          docker rm -f test-app-${{ github.run_id }} test-redis-${{ github.run_id }} test-postgres-${{ github.run_id }} 2>/dev/null || true
          
          # Create test network
          docker network create $TEST_NETWORK
          
          # Start test services
          docker run -d --name test-redis-${{ github.run_id }} --network $TEST_NETWORK \
            redis:7-alpine redis-server --maxmemory 64mb
          
          docker run -d --name test-postgres-${{ github.run_id }} --network $TEST_NETWORK \
            -e POSTGRES_DB=blacklist -e POSTGRES_USER=test -e POSTGRES_PASSWORD=test \
            postgres:15-alpine
          
          # Wait for services
          sleep 10
          
          # Test main application
          docker run -d --name test-app-${{ github.run_id }} --network $TEST_NETWORK \
            -p $TEST_PORT:2542 \
            -e DATABASE_URL="postgresql://test:test@test-postgres-${{ github.run_id }}:5432/blacklist" \
            -e REDIS_URL="redis://test-redis-${{ github.run_id }}:6379/0" \
            -e COLLECTION_ENABLED=false \
            -e FORCE_DISABLE_COLLECTION=true \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          
          # Health check with timeout
          echo "â³ Waiting for application to be ready..."
          for i in {1..30}; do
            if curl -sf http://localhost:$TEST_PORT/health > /dev/null 2>&1; then
              echo "âœ… Application is responding"
              
              # Test API endpoints
              curl -f http://localhost:$TEST_PORT/health | jq .
              curl -f http://localhost:$TEST_PORT/ready || echo "Readiness endpoint optional"
              
              break
            fi
            sleep 2
          done
          
          # Cleanup
          docker rm -f test-app-${{ github.run_id }} test-redis-${{ github.run_id }} test-postgres-${{ github.run_id }}
          docker network rm $TEST_NETWORK

      - name: Performance benchmark
        run: |
          echo "âš¡ Running performance benchmark..."
          
          # Simple load test on the registry image
          TEST_PORT=4$(shuf -i 5000-5999 -n 1)
          
          docker run -d --name perf-test-${{ github.run_id }} \
            -p $TEST_PORT:2542 \
            -e COLLECTION_ENABLED=false \
            -e FORCE_DISABLE_COLLECTION=true \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          
          sleep 5
          
          # Performance test
          echo "ðŸ”„ Testing response time..."
          for i in {1..5}; do
            curl -w "Response time: %{time_total}s\n" -o /dev/null -s http://localhost:$TEST_PORT/health
          done
          
          # Cleanup
          docker rm -f perf-test-${{ github.run_id }}

  # Release job for main branch
  release:
    name: ðŸŽ‰ Create Release
    runs-on: self-hosted
    needs: [prepare, build, verify-deployment]
    if: github.ref == 'refs/heads/main' && needs.build.result == 'success'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create GitHub Release
        run: |
          echo "ðŸŽ¯ Creating GitHub Release v${{ needs.prepare.outputs.version }}"
          
          # Create release with gh CLI
          gh release create "v${{ needs.prepare.outputs.version }}" \
            --title "Release v${{ needs.prepare.outputs.version }}" \
            --notes "ðŸš€ **Blacklist Management System v${{ needs.prepare.outputs.version }}**

          **ðŸ“¦ Docker Images:**
          - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${{ needs.prepare.outputs.version }}\`
          - \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest\`
          
          **ðŸ”’ Security:**
          - Trivy vulnerability scan passed
          - Bandit security analysis passed
          - Dependencies vulnerability check passed
          
          **ðŸ“Š Performance:**
          - Response time < 100ms
          - Memory usage optimized
          - Cache layers optimized
          
          **âœ… Testing:**
          - Unit tests: Passed
          - Integration tests: Passed
          - API tests: Passed
          - Security scan: Passed
          
          **ðŸŒ Deployment:**
          - Live System: https://blacklist.jclee.me/
          - Documentation: https://jclee94.github.io/blacklist/
          
          **ðŸ”§ Installation:**
          \`\`\`bash
          docker-compose pull && docker-compose up -d
          \`\`\`" \
            --latest 2>/dev/null || echo "âš ï¸ Release creation failed - continuing"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Cleanup job
  cleanup:
    name: ðŸ§¹ Cleanup
    runs-on: self-hosted
    needs: [prepare, build, verify-deployment, release]
    if: always()
    steps:
      - name: Docker cleanup
        run: |
          echo "ðŸ§¹ Performing cleanup..."
          
          # Remove unused images (keep last 3 versions)
          docker images | grep ${{ env.IMAGE_NAME }} | sort -k2 -V | head -n -3 | awk '{print $3}' | xargs -r docker rmi || true
          
          # Cleanup build cache (keep last 1GB)
          docker buildx prune -f --keep-storage 1gb || true
          
          # System cleanup
          docker system prune -f --volumes || true

      - name: Performance metrics
        run: |
          echo "ðŸ“Š Build Performance Metrics:"
          echo "=========================="
          echo "Build Duration: ${{ github.event.head_commit.timestamp }}"
          echo "Cache Hit Rate: $(docker buildx imagetools inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache --format '{{.Cache}}' 2>/dev/null || echo 'N/A')"
          echo "Final Image Size: $(docker images --format 'table {{.Repository}}:{{.Tag}}\t{{.Size}}' | grep ${{ env.IMAGE_NAME }}:latest | awk '{print $2}')"
          echo "Test Coverage: $(grep -o 'Total coverage: [0-9]*%' test-results-*/coverage.xml 2>/dev/null | tail -1 || echo 'N/A')"

      - name: Logout from registry
        if: always()
        run: docker logout ${{ env.REGISTRY }} || true