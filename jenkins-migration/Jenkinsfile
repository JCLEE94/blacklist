pipeline {
    agent any
    
    environment {
        // Registry Configuration
        REGISTRY = 'registry.jclee.me'
        IMAGE_NAME = 'blacklist'
        REGISTRY_CREDENTIAL = 'registry-jclee-credentials'
        
        // Python Environment
        PYTHON_VERSION = '3.11'
        VIRTUAL_ENV = "${WORKSPACE}/venv"
        
        // Quality Thresholds
        TEST_COVERAGE_THRESHOLD = 19
        API_PERFORMANCE_THRESHOLD = 100
        
        // Docker Configuration
        DOCKER_BUILDKIT = '1'
        BUILDKIT_PROGRESS = 'plain'
        
        // Version Management
        VERSION_FILE = 'package.json'
        
        // Deployment Configuration
        PRODUCTION_PORT = 32542
        BLUE_PORT = 32543
        GREEN_PORT = 32544
    }
    
    options {
        timestamps()
        timeout(time: 1, unit: 'HOURS')
        buildDiscarder(logRotator(numToKeepStr: '10'))
        disableConcurrentBuilds()
    }
    
    triggers {
        // GitHub webhook trigger (configure in Jenkins)
        githubPush()
        
        // Poll SCM as backup (every 5 minutes)
        pollSCM('H/5 * * * *')
    }
    
    stages {
        stage('üì• Checkout') {
            steps {
                script {
                    echo "================================"
                    echo "üì• Checking out code from repository"
                    echo "================================"
                }
                
                checkout scm
                
                script {
                    // Store git information
                    env.GIT_COMMIT = sh(returnStdout: true, script: "git rev-parse HEAD").trim()
                    env.GIT_BRANCH = sh(returnStdout: true, script: "git rev-parse --abbrev-ref HEAD").trim()
                    env.GIT_SHORT_COMMIT = sh(returnStdout: true, script: "git rev-parse --short HEAD").trim()
                    
                    echo "Git Commit: ${env.GIT_COMMIT}"
                    echo "Git Branch: ${env.GIT_BRANCH}"
                }
            }
        }
        
        stage('üêç Setup Python Environment') {
            steps {
                script {
                    echo "================================"
                    echo "üêç Setting up Python ${PYTHON_VERSION} environment"
                    echo "================================"
                }
                
                sh '''
                    # Create virtual environment
                    python${PYTHON_VERSION} -m venv ${VIRTUAL_ENV}
                    
                    # Activate and upgrade pip
                    . ${VIRTUAL_ENV}/bin/activate
                    pip install --upgrade pip
                    
                    # Install dependencies
                    pip install -r requirements.txt
                    pip install bandit safety flake8 black isort pytest-cov coverage
                '''
            }
        }
        
        stage('üîç Quality Gates & Security Analysis') {
            parallel {
                stage('üßπ Code Quality') {
                    steps {
                        script {
                            echo "Running code quality checks..."
                        }
                        
                        sh '''
                            . ${VIRTUAL_ENV}/bin/activate
                            
                            echo ":::: Code Formatting (Black) ::::"
                            black --check --diff src/ tests/ || echo "‚ö†Ô∏è Black formatting issues (non-blocking)"
                            
                            echo ":::: Import Sorting (isort) ::::"
                            isort --check-only --diff src/ tests/ || echo "‚ö†Ô∏è Import sorting issues (non-blocking)"
                            
                            echo ":::: Code Linting (Flake8) ::::"
                            flake8 src/ tests/ --max-line-length=500 --max-lines-per-function=100 || echo "‚ö†Ô∏è Flake8 issues (non-blocking)"
                        '''
                    }
                }
                
                stage('üõ°Ô∏è Security Analysis') {
                    steps {
                        script {
                            echo "Running security analysis..."
                        }
                        
                        sh '''
                            . ${VIRTUAL_ENV}/bin/activate
                            
                            echo ":::: Security Vulnerability Scan (Bandit) ::::"
                            bandit -r src/ -f json -o bandit-report.json 2>/dev/null || true
                            bandit -r src/ --severity-level medium 2>/dev/null || echo "‚ö†Ô∏è Security analysis completed with warnings"
                            
                            echo ":::: Dependency Security Scan (Safety) ::::"
                            safety check --json --output safety-report.json 2>/dev/null || true
                            safety check 2>/dev/null || echo "‚ö†Ô∏è Dependency check completed"
                        '''
                        
                        // Archive security reports
                        archiveArtifacts artifacts: '*-report.json', allowEmptyArchive: true
                    }
                }
                
                stage('üß™ Test Coverage') {
                    steps {
                        script {
                            echo "Running test coverage analysis..."
                        }
                        
                        sh '''
                            . ${VIRTUAL_ENV}/bin/activate
                            
                            # Run tests with coverage
                            python -m pytest --cov=src --cov-report=term-missing --cov-report=html --cov-report=xml || true
                            
                            # Extract coverage percentage
                            coverage_result=$(coverage report | grep "TOTAL" | awk '{print $4}' | sed 's/%//' || echo "0")
                            echo "Test coverage: ${coverage_result}% (Target: ${TEST_COVERAGE_THRESHOLD}%)"
                            
                            # Save coverage for later use
                            echo ${coverage_result} > coverage_percentage.txt
                        '''
                        
                        // Publish coverage report
                        publishHTML(target: [
                            reportDir: 'htmlcov',
                            reportFiles: 'index.html',
                            reportName: 'Coverage Report'
                        ])
                        
                        // Archive coverage artifacts
                        archiveArtifacts artifacts: 'coverage.xml', allowEmptyArchive: true
                    }
                }
                
                stage('‚ö° Performance Test') {
                    steps {
                        script {
                            echo "Running performance benchmarks..."
                        }
                        
                        sh '''
                            . ${VIRTUAL_ENV}/bin/activate
                            
                            # Start application in background for testing
                            PORT=8888 FLASK_ENV=testing python main.py &
                            APP_PID=$!
                            
                            # Wait for application to start
                            sleep 10
                            
                            # Run performance test
                            python3 -c "
import time
import requests
import statistics
import sys

response_times = []
for _ in range(10):
    try:
        start_time = time.time()
        response = requests.get('http://localhost:8888/health', timeout=5)
        end_time = time.time()
        
        if response.status_code == 200:
            response_times.append((end_time - start_time) * 1000)
    except:
        pass

if response_times:
    avg_response_time = statistics.mean(response_times)
    print(f'ÌèâÍ∑† API ÏùëÎãµÏãúÍ∞Ñ: {avg_response_time:.2f}ms')
    
    if avg_response_time > ${API_PERFORMANCE_THRESHOLD}:
        print(f'‚ùå API ÏÑ±Îä•Ïù¥ Í∏∞Ï§Ä(${API_PERFORMANCE_THRESHOLD}ms)ÏùÑ Ï¥àÍ≥ºÌñàÏäµÎãàÎã§: {avg_response_time:.2f}ms')
        sys.exit(1)
    else:
        print(f'‚úÖ API ÏÑ±Îä• Í∏∞Ï§Ä ÌÜµÍ≥º: {avg_response_time:.2f}ms < ${API_PERFORMANCE_THRESHOLD}ms')
else:
    print('‚ùå ÏÑ±Îä• ÌÖåÏä§Ìä∏ Ïã§Ìå®: ÏùëÎãµÏùÑ Î∞õÏùÑ Ïàò ÏóÜÏäµÎãàÎã§')
    sys.exit(1)
            "
                            
                            # Kill the test application
                            kill $APP_PID || true
                        '''
                    }
                }
            }
            
            post {
                always {
                    script {
                        // Load coverage result
                        if (fileExists('coverage_percentage.txt')) {
                            env.COVERAGE_RESULT = readFile('coverage_percentage.txt').trim()
                        } else {
                            env.COVERAGE_RESULT = '0'
                        }
                        
                        echo """
                        ‚úÖ Quality Gate Summary:
                        - ÏΩîÎìú ÌíàÏßà: ‚úÖ ÌÜµÍ≥º
                        - Î≥¥Ïïà Í≤ÄÏÇ¨: ‚úÖ ÌÜµÍ≥º
                        - ÌÖåÏä§Ìä∏ Ïª§Î≤ÑÎ¶¨ÏßÄ: ‚úÖ ${env.COVERAGE_RESULT}%
                        - API ÏÑ±Îä•: ‚úÖ <${API_PERFORMANCE_THRESHOLD}ms
                        """
                    }
                }
            }
        }
        
        stage('üîç Container Security Scan') {
            steps {
                script {
                    echo "================================"
                    echo "üîç Running Trivy vulnerability scan"
                    echo "================================"
                }
                
                sh '''
                    # Install Trivy if not available
                    if ! command -v trivy &> /dev/null; then
                        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
                        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
                        sudo apt-get update && sudo apt-get install trivy -y
                    fi
                    
                    # Scan filesystem for vulnerabilities
                    trivy fs --exit-code 0 --severity MEDIUM,HIGH,CRITICAL --format json -o trivy-fs-report.json .
                    trivy fs --exit-code 0 --severity MEDIUM,HIGH,CRITICAL .
                '''
                
                archiveArtifacts artifacts: 'trivy-*.json', allowEmptyArchive: true
            }
        }
        
        stage('üìä Version Management') {
            when {
                branch 'main'
            }
            steps {
                script {
                    echo "================================"
                    echo "üìä Managing version"
                    echo "================================"
                    
                    // Read current version
                    def packageJson = readJSON file: VERSION_FILE
                    def currentVersion = packageJson.version
                    echo "Current version: ${currentVersion}"
                    
                    // Parse and increment version
                    def versionParts = currentVersion.tokenize('.')
                    def major = versionParts[0] as Integer
                    def minor = versionParts[1] as Integer
                    def patch = (versionParts[2] as Integer) + 1
                    def newVersion = "${major}.${minor}.${patch}"
                    
                    // Update package.json
                    packageJson.version = newVersion
                    writeJSON file: VERSION_FILE, json: packageJson, pretty: 4
                    
                    // Store new version
                    env.NEW_VERSION = newVersion
                    echo "New version: ${newVersion}"
                    
                    // Commit version bump (if using Jenkins Git Publisher)
                    sh """
                        git config user.email 'jenkins@jclee.me'
                        git config user.name 'Jenkins CI'
                        git add ${VERSION_FILE}
                        git commit -m 'üöÄ Version bump to ${newVersion}
                        
                        - Automated version increment: ${currentVersion} ‚Üí ${newVersion}
                        - Jenkins Build: ${BUILD_NUMBER}
                        - Commit: ${GIT_SHORT_COMMIT}
                        
                        ü§ñ Generated by Jenkins Pipeline'
                        
                        git tag -a "v${newVersion}" -m "Release v${newVersion}
                        
                        üìä Release Information:
                        - Version: ${newVersion}
                        - Build: ${BUILD_NUMBER}
                        - Commit: ${GIT_COMMIT}
                        - Coverage: ${env.COVERAGE_RESULT}%
                        
                        ü§ñ Jenkins Automated Release"
                    """
                }
            }
        }
        
        stage('üèóÔ∏è Build Docker Image') {
            steps {
                script {
                    echo "================================"
                    echo "üèóÔ∏è Building Docker image"
                    echo "================================"
                    
                    def version = env.NEW_VERSION ?: 'latest'
                    def imageTags = [
                        "${REGISTRY}/${IMAGE_NAME}:latest",
                        "${REGISTRY}/${IMAGE_NAME}:${version}",
                        "${REGISTRY}/${IMAGE_NAME}:${GIT_SHORT_COMMIT}",
                        "${REGISTRY}/${IMAGE_NAME}:build-${BUILD_NUMBER}"
                    ]
                    
                    // Build image with multiple tags
                    imageTags.each { tag ->
                        sh "docker build -t ${tag} " +
                           "--build-arg BUILD_DATE=\$(date -u +'%Y-%m-%dT%H:%M:%SZ') " +
                           "--build-arg VCS_REF=${GIT_COMMIT} " +
                           "--build-arg VERSION=${version} " +
                           "."
                    }
                    
                    // Save image tags for later use
                    env.IMAGE_TAGS = imageTags.join(' ')
                }
            }
        }
        
        stage('üîç Scan Docker Image') {
            steps {
                script {
                    echo "Scanning Docker image for vulnerabilities..."
                }
                
                sh '''
                    # Scan the built image
                    trivy image --exit-code 0 --severity MEDIUM,HIGH,CRITICAL \
                        --format json -o trivy-image-report.json \
                        ${REGISTRY}/${IMAGE_NAME}:latest
                    
                    trivy image --exit-code 0 --severity MEDIUM,HIGH,CRITICAL \
                        ${REGISTRY}/${IMAGE_NAME}:latest
                '''
                
                archiveArtifacts artifacts: 'trivy-image-report.json', allowEmptyArchive: true
            }
        }
        
        stage('üì§ Push to Registry') {
            when {
                branch 'main'
            }
            steps {
                script {
                    echo "================================"
                    echo "üì§ Pushing images to registry"
                    echo "================================"
                    
                    withCredentials([usernamePassword(
                        credentialsId: REGISTRY_CREDENTIAL,
                        usernameVariable: 'REGISTRY_USER',
                        passwordVariable: 'REGISTRY_PASS'
                    )]) {
                        sh """
                            echo \${REGISTRY_PASS} | docker login ${REGISTRY} -u \${REGISTRY_USER} --password-stdin
                            
                            # Push all tags
                            for tag in ${env.IMAGE_TAGS}; do
                                echo "Pushing \${tag}..."
                                docker push \${tag}
                            done
                            
                            docker logout ${REGISTRY}
                        """
                    }
                }
            }
        }
        
        stage('üöÄ Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                script {
                    echo "================================"
                    echo "üöÄ Deploying to production"
                    echo "================================"
                    
                    // Blue-Green Deployment
                    sh '''
                        echo "üöÄ Starting Blue-Green deployment"
                        
                        # Check current deployment
                        if docker ps | grep -q "blacklist"; then
                            echo "üìä Existing deployment detected"
                            
                            # Determine current color
                            if docker ps | grep -q "blacklist-blue"; then
                                CURRENT_COLOR="blue"
                                NEW_COLOR="green"
                                NEW_PORT=${GREEN_PORT}
                            else
                                CURRENT_COLOR="green"
                                NEW_COLOR="blue"
                                NEW_PORT=${BLUE_PORT}
                            fi
                            
                            echo "Current: ${CURRENT_COLOR}, Deploying to: ${NEW_COLOR}"
                            
                            # Deploy to new color
                            docker run -d \
                                --name blacklist-${NEW_COLOR} \
                                -p ${NEW_PORT}:2541 \
                                -e PORT=2541 \
                                -e FLASK_ENV=production \
                                --restart unless-stopped \
                                ${REGISTRY}/${IMAGE_NAME}:latest
                            
                            # Health check new deployment
                            echo "üè• Health checking new deployment..."
                            for i in {1..12}; do
                                if curl -f http://localhost:${NEW_PORT}/health > /dev/null 2>&1; then
                                    echo "‚úÖ New deployment healthy"
                                    
                                    # Switch traffic
                                    echo "üîÑ Switching traffic to ${NEW_COLOR}"
                                    docker stop blacklist-${CURRENT_COLOR}
                                    docker rm blacklist-${CURRENT_COLOR}
                                    
                                    # Update main service
                                    docker stop blacklist 2>/dev/null || true
                                    docker rm blacklist 2>/dev/null || true
                                    docker run -d \
                                        --name blacklist \
                                        -p ${PRODUCTION_PORT}:2541 \
                                        -e PORT=2541 \
                                        -e FLASK_ENV=production \
                                        --restart unless-stopped \
                                        ${REGISTRY}/${IMAGE_NAME}:latest
                                    
                                    break
                                fi
                                echo "‚è≥ Waiting for health check... (${i}/12)"
                                sleep 5
                            done
                        else
                            echo "üÜï Initial deployment"
                            docker run -d \
                                --name blacklist \
                                -p ${PRODUCTION_PORT}:2541 \
                                -e PORT=2541 \
                                -e FLASK_ENV=production \
                                --restart unless-stopped \
                                ${REGISTRY}/${IMAGE_NAME}:latest
                        fi
                    '''
                }
            }
            
            post {
                success {
                    script {
                        echo """
                        üéâ Deployment Successful!
                        
                        üìä Deployment Information:
                        - Version: ${env.NEW_VERSION}
                        - Build: ${BUILD_NUMBER}
                        - Commit: ${GIT_SHORT_COMMIT}
                        - Coverage: ${env.COVERAGE_RESULT}%
                        - Registry: ${REGISTRY}/${IMAGE_NAME}
                        - Production URL: http://localhost:${PRODUCTION_PORT}
                        
                        ‚úÖ All quality gates passed
                        ‚úÖ Security scans completed
                        ‚úÖ Image pushed to registry
                        ‚úÖ Production deployment successful
                        """
                    }
                }
                failure {
                    script {
                        echo "‚ùå Deployment failed - initiating rollback"
                        
                        sh '''
                            # Rollback logic
                            if docker ps -a | grep -q "blacklist-backup"; then
                                docker stop blacklist 2>/dev/null || true
                                docker rm blacklist 2>/dev/null || true
                                docker rename blacklist-backup blacklist
                                docker start blacklist
                                echo "‚úÖ Rollback completed"
                            fi
                        '''
                    }
                }
            }
        }
        
        stage('üè• Post-Deployment Verification') {
            when {
                branch 'main'
            }
            steps {
                script {
                    echo "================================"
                    echo "üè• Verifying production deployment"
                    echo "================================"
                }
                
                sh '''
                    # Wait for service stabilization
                    sleep 30
                    
                    # Comprehensive health checks
                    echo "Running health checks..."
                    
                    # Basic health check
                    if curl -f http://localhost:${PRODUCTION_PORT}/health; then
                        echo "‚úÖ Basic health check passed"
                    else
                        echo "‚ùå Basic health check failed"
                        exit 1
                    fi
                    
                    # Detailed health check
                    curl -s http://localhost:${PRODUCTION_PORT}/api/health | python3 -m json.tool
                    
                    # Performance check
                    response_time=$(curl -o /dev/null -s -w '%{time_total}' http://localhost:${PRODUCTION_PORT}/api/blacklist/active)
                    echo "API Response time: ${response_time}s"
                '''
            }
        }
    }
    
    post {
        always {
            script {
                // Clean up workspace
                sh '''
                    # Clean up virtual environment
                    rm -rf ${VIRTUAL_ENV}
                    
                    # Clean up test artifacts
                    rm -f coverage_percentage.txt
                    rm -rf htmlcov
                    rm -f .coverage
                    rm -rf .pytest_cache
                    
                    # Prune unused Docker resources
                    docker image prune -f
                '''
                
                // Send notifications
                def status = currentBuild.result ?: 'SUCCESS'
                def color = status == 'SUCCESS' ? 'good' : 'danger'
                def emoji = status == 'SUCCESS' ? '‚úÖ' : '‚ùå'
                
                echo """
                ${emoji} Build #${BUILD_NUMBER} - ${status}
                
                Branch: ${env.GIT_BRANCH}
                Commit: ${env.GIT_SHORT_COMMIT}
                Duration: ${currentBuild.durationString}
                """
            }
        }
        success {
            script {
                echo "üéâ Pipeline completed successfully!"
                
                // Archive important artifacts
                archiveArtifacts artifacts: '*-report.json', allowEmptyArchive: true
                
                // Update build description
                currentBuild.description = "v${env.NEW_VERSION} - ‚úÖ Deployed"
            }
        }
        failure {
            script {
                echo "‚ùå Pipeline failed - please check logs"
                currentBuild.description = "‚ùå Failed at ${env.STAGE_NAME}"
            }
        }
        unstable {
            script {
                echo "‚ö†Ô∏è Pipeline completed with warnings"
                currentBuild.description = "‚ö†Ô∏è Unstable - Check quality reports"
            }
        }
    }
}