apiVersion: v1
kind: ServiceAccount
metadata:
  name: image-updater
  namespace: blacklist
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: image-updater
rules:
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "patch", "update"]
- apiGroups: [""]
  resources: ["services", "nodes"]
  verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: image-updater
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: image-updater
subjects:
- kind: ServiceAccount
  name: image-updater
  namespace: blacklist
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: auto-update-script
  namespace: blacklist
data:
  auto-update.sh: |
    #!/bin/bash
    # 단발성 이미지 업데이트 체크 스크립트 (CronJob용)
    
    echo "🔄 $(date '+%Y-%m-%d %H:%M:%S') - 이미지 업데이트 체크 시작"
    
    # 설정
    NAMESPACE="blacklist"
    REGISTRY="registry.jclee.me"
    IMAGE_NAME="blacklist"
    
    # 현재 배포된 이미지 가져오기
    current_image=$(kubectl get deployment blacklist -n $NAMESPACE -o jsonpath='{.spec.template.spec.containers[0].image}' 2>/dev/null)
    if [ -z "$current_image" ]; then
        echo "❌ 현재 배포 정보를 가져올 수 없음"
        exit 1
    fi
    
    current_tag=$(echo "$current_image" | cut -d':' -f2)
    echo "📋 현재 이미지: $current_image"
    
    # Registry API로 최신 태그 확인 (GitHub Actions가 푸시한 최신 SHA)
    echo "🔍 Registry에서 최신 이미지 확인 중..."
    
    # Docker Registry API v2 사용하여 최신 SHA 태그 가져오기
    auth_header=""
    if [ -n "$REGISTRY_USER" ] && [ -n "$REGISTRY_PASS" ]; then
        auth_string=$(echo -n "$REGISTRY_USER:$REGISTRY_PASS" | base64 -w 0)
        auth_header="-H \"Authorization: Basic $auth_string\""
        echo "🔐 Registry 인증 설정됨"
    else
        echo "⚠️ Registry 인증 정보 없음"
    fi
    
    # 다양한 태그 패턴 시도하여 최신 이미지 감지
    echo "🔍 Registry API 응답 확인 중..."
    if [ -n "$auth_header" ]; then
        registry_response=$(curl -s -H "Authorization: Basic $auth_string" "https://$REGISTRY/v2/$IMAGE_NAME/tags/list")
    else
        registry_response=$(curl -s "https://$REGISTRY/v2/$IMAGE_NAME/tags/list")
    fi
    echo "Registry 응답: $(echo "$registry_response" | head -c 200)..."
    
    # 1차: SHA 태그 찾기 (7-8자리)
    latest_tag=$(echo "$registry_response" | \
        jq -r '.tags[]?' 2>/dev/null | \
        grep -E '^[a-f0-9]{7,8}$' | \
        sort -r | \
        head -1)
    
    # 2차: 날짜 기반 태그 찾기 (YYYYMMDD-HHMM 형식)
    if [ -z "$latest_tag" ]; then
        latest_tag=$(echo "$registry_response" | \
            jq -r '.tags[]?' 2>/dev/null | \
            grep -E '^[0-9]{8}-[0-9]{4}' | \
            sort -r | \
            head -1)
    fi
    
    # 3차: GitHub Actions 빌드 태그 찾기
    if [ -z "$latest_tag" ]; then
        latest_tag=$(echo "$registry_response" | \
            jq -r '.tags[]?' 2>/dev/null | \
            grep -E '^(main|build|deploy)-[a-f0-9]{7,}' | \
            sort -r | \
            head -1)
    fi
    
    # 최후: latest 태그 사용
    if [ -z "$latest_tag" ] || [ "$latest_tag" = "null" ]; then
        echo "⚠️ Registry에서 적절한 태그를 찾을 수 없음 - latest 태그 사용"
        latest_tag="latest"
    fi
    
    echo "🏷️  최신 태그: $latest_tag"
    
    # 태그 비교 및 업데이트
    if [ "$current_tag" != "$latest_tag" ]; then
        echo "🆕 새로운 이미지 발견! 업데이트 시작..."
        echo "   현재: $current_tag → 새로운: $latest_tag"
        new_image="$REGISTRY/$IMAGE_NAME:$latest_tag"
        
        # 업데이트 전 백업 - 현재 deployment 정보 저장
        kubectl get deployment blacklist -n $NAMESPACE -o yaml > /tmp/blacklist-backup-$(date +%Y%m%d-%H%M%S).yaml
        
        # 이미지 존재 확인
        echo "🔍 새 이미지 존재 확인 중..."
        if [ -n "$auth_header" ]; then
            manifest_response=$(curl -f -s -H "Authorization: Basic $auth_string" "https://$REGISTRY/v2/$IMAGE_NAME/manifests/$latest_tag" 2>/dev/null)
        else
            manifest_response=$(curl -f -s "https://$REGISTRY/v2/$IMAGE_NAME/manifests/$latest_tag" 2>/dev/null)
        fi
        
        if [ -z "$manifest_response" ]; then
            echo "❌ 이미지 $new_image가 존재하지 않음"
            exit 1
        fi
        
        # 이미지 업데이트 (어노테이션으로 강제 롤아웃)
        kubectl set image deployment/blacklist \
            blacklist="$new_image" \
            -n $NAMESPACE
        
        kubectl annotate deployment blacklist \
            deployment.kubernetes.io/revision- \
            -n $NAMESPACE 2>/dev/null || true
            
        kubectl patch deployment blacklist \
            -p '{"spec":{"template":{"metadata":{"annotations":{"updated":"'$(date +%s)'"}}}}' \
            -n $NAMESPACE
        
        # 롤아웃 상태 확인 (더 긴 타임아웃)
        echo "⏳ 롤아웃 상태 확인 중..."
        if kubectl rollout status deployment/blacklist -n $NAMESPACE --timeout=600s; then
            echo "✅ 이미지 업데이트 성공: $new_image"
            
            # 헬스 체크 (재시도 로직 포함)
            echo "🏥 헬스 체크 시작..."
            for i in {1..5}; do
                sleep 15
                NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="InternalIP")].address}')
                NODE_PORT=$(kubectl get svc blacklist-nodeport -n $NAMESPACE -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "32541")
                
                if curl -f -s --connect-timeout 10 --max-time 15 "http://$NODE_IP:$NODE_PORT/health" > /dev/null 2>&1; then
                    echo "✅ 헬스 체크 통과 (시도 $i/5)"
                    
                    # Pod 상태 최종 확인
                    ready_pods=$(kubectl get deployment blacklist -n $NAMESPACE -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
                    total_pods=$(kubectl get deployment blacklist -n $NAMESPACE -o jsonpath='{.spec.replicas}' 2>/dev/null || echo "1")
                    
                    echo "📊 Pod 상태: $ready_pods/$total_pods Ready"
                    echo "🎉 자동 업데이트 완료!"
                    
                    # 성공 메트릭 기록
                    kubectl annotate deployment blacklist \
                        last-successful-update="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                        last-updated-image="$new_image" \
                        -n $NAMESPACE
                    break
                else
                    echo "⚠️ 헬스 체크 실패 (시도 $i/5) - 15초 후 재시도..."
                    if [ $i -eq 5 ]; then
                        echo "❌ 헬스 체크 최종 실패 - 롤백 고려 필요"
                        
                        # 실패 시 이벤트 기록
                        kubectl annotate deployment blacklist \
                            last-failed-update="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                            failed-image="$new_image" \
                            -n $NAMESPACE
                        exit 1
                    fi
                fi
            done
        else
            echo "❌ 이미지 업데이트 실패 - 롤아웃 타임아웃"
            exit 1
        fi
    else
        echo "✅ 이미지가 이미 최신 상태"
        
        # 최신 상태 확인 메트릭 업데이트
        kubectl annotate deployment blacklist \
            last-check="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            current-image="$current_image" \
            -n $NAMESPACE
    fi
    
    echo "🏁 $(date '+%Y-%m-%d %H:%M:%S') - 이미지 업데이트 체크 완료"
---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: auto-image-updater
  namespace: blacklist
spec:
  # 2분마다 실행
  schedule: "*/2 * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: image-updater
          restartPolicy: OnFailure
          containers:
          - name: updater
            image: alpine/k8s:1.28.4
            env:
            - name: REGISTRY_USER
              value: "qws9411"
            - name: REGISTRY_PASS
              value: "bingogo1"
            command: ["/bin/bash"]
            args: ["/scripts/auto-update.sh"]
            volumeMounts:
            - name: update-script
              mountPath: /scripts
          volumes:
          - name: update-script
            configMap:
              name: auto-update-script
              defaultMode: 0755
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1